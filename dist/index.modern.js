import{P2PKH as t,LockingScript as e,Script as n,Utils as o,fromUtxo as s,SatoshisPerKilobyte as i,Transaction as r,OP as a,BigNumber as c,UnlockingScript as u,TransactionSignature as f}from"@bsv/sdk";import{Sigma as d}from"sigma-protocol";const l=t=>Buffer.from(t).toString("hex"),p=10,g="https://ordinals.gorillapool.io/api";class h extends t{lock(n,o,s,i){let r="";if(void 0!==o&&void 0!==s){const t=l("ord"),e=Buffer.from(o,"base64").toString("hex").trim();if(!e)throw new Error("Invalid file data");const n=l(s);if(!n)throw new Error("Invalid media type");r=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${e} OP_ENDIF`}let a=`${r?`${r} `:""}${(new t).lock(n).toASM()}`;if(i&&(!i.app||!i.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=i&&i.app&&null!=i&&i.type){a=`${a} OP_RETURN ${l("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${l("SET")}`;for(const[t,e]of Object.entries(i))"cmd"!==t&&(a=`${a} ${l(t)} ${l(e)}`)}return e.fromASM(a)}}function w(){return w=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)({}).hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},w.apply(null,arguments)}var m,y;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(m||(m={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(y||(y={}));const{fromBase58Check:b}=o,x=(t,e)=>s(w({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),e),k=async(e,n="base64")=>{const o=`${g}/txos/address/${e}/unspent?bsv20=false`;console.log({payUrl:o});const s=await fetch(o);if(!s.ok)throw new Error("Error fetching pay utxos");let i=await s.json();i=i.filter(t=>1!==t.satoshis);const r=b(e),a=(new t).lock(r.data);return i=i.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===n||"base64"===n?Buffer.from(a.toBinary()).toString(n):a.toASM()})),i},S=async(t,e,o=10,s=0,i="base64")=>{let r=`${g}/txos/address/${t}/unspent?limit=${o}&offset=${s}&`;e&&(r+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:e}}})).toString("base64")}`);const a=await fetch(r);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var e;return 1===t.satoshis&&!(null!=(e=t.data)&&e.list)});const u=c.map(t=>`${t.txid}_${t.vout}`),f=await fetch(`${g}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...u])});if(!f.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await f.json()||[]).map(t=>{let o=t.script;"hex"===i?o=Buffer.from(o,"base64").toString("hex"):"asm"===i&&(o=n.fromHex(Buffer.from(o,"base64").toString("hex")).toASM());const s={origin:t.origin.outpoint,script:o,vout:t.vout,txid:t.txid,satoshis:1};return e&&(s.collectionId=e),s}),c},I=async(t,e,n)=>{const o=`${g}/bsv20/${n}/${t===m.BSV20?"tick":"id"}/${e}?bsv20=true&listing=false`,s=await fetch(o);if(!s.ok)throw new Error(`Error fetching ${t} utxos`);let i=await s.json();return i=i.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:e,satoshis:1})),i},O=async(t,e)=>{const n=null==e?void 0:e.idKey,o=null==e?void 0:e.keyHost;if(n){const e=new d(t),{signedTx:o}=e.sign(n);return o}if(o){const n=null==e?void 0:e.authToken,s=new d(t);try{const{signedTx:t}=await s.remoteSign(o,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${o} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},B=t=>{if(!t)return;const e={app:t.app,type:t.type};for(const[n,o]of Object.entries(t))void 0!==o&&(e[n]="string"==typeof o?o:Array.isArray(o)||"object"==typeof o?JSON.stringify(o):String(o));return e},v=async e=>{const{utxos:n,destinations:o,paymentPk:s,changeAddress:a,satsPerKb:c=p,metaData:u,signer:f,additionalPayments:d=[]}=e,l=new i(c);let g=new r;for(const e of n){const n=x(e,(new t).unlock(s));g.addInput(n)}o.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of o){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(u)for(const t of Object.keys(u))void 0===u[t]&&delete u[t];g.addOutput({satoshis:1,lockingScript:(new h).lock(t.address,t.inscription.dataB64,t.inscription.contentType,B(u))})}for(const e of d)g.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});const w=n.reduce((t,e)=>t+BigInt(e.satoshis),0n),m=g.outputs.reduce((t,e)=>t+BigInt(e.satoshis||0),0n),y=await l.computeFee(g);let b;if(w>m+BigInt(y)){const e=(new t).lock(a||s.toAddress().toString()),n={lockingScript:e,change:!0};b={txid:"",vout:g.outputs.length,satoshis:0,script:Buffer.from(e.toHex(),"hex").toString("base64")},g.addOutput(n)}return f&&(g=await O(g,f)),await g.fee(l),await g.sign(),b&&(b.satoshis=g.outputs[g.outputs.length-1].satoshis,b.txid=g.id("hex")),{tx:g,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:b}},$=async e=>{e.satsPerKb||(e.satsPerKb=p),e.additionalPayments||(e.additionalPayments=[]),void 0===e.enforceUniformSend&&(e.enforceUniformSend=!0);const n=new i(e.satsPerKb);let o=new r;const s=[];for(const t of e.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=x(t,(new h).unlock(e.ordPk));s.push(`${t.txid}_${t.vout}`),o.addInput(n)}if(e.enforceUniformSend&&e.destinations.length!==e.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of e.destinations){var a,c;let s;s=null!=(a=n.inscription)&&a.dataB64&&null!=(c=n.inscription)&&c.contentType?(new h).lock(n.address,n.inscription.dataB64,n.inscription.contentType,B(e.metaData)):(new t).lock(n.address),o.addOutput({satoshis:1,lockingScript:s})}for(const n of e.additionalPayments)o.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});let u=0n;const f=o.outputs.reduce((t,e)=>t+BigInt(e.satoshis||0),0n);let d,l=0;for(const i of e.paymentUtxos){const r=x(i,(new t).unlock(e.paymentPk));if(s.push(`${i.txid}_${i.vout}`),o.addInput(r),u+=BigInt(i.satoshis),l=await n.computeFee(o),u>=f+BigInt(l))break}if(u<f)throw new Error("Not enough ordinals to send");if(u>f+BigInt(l)){const n=(new t).lock(e.changeAddress||e.paymentPk.toAddress().toString()),s={lockingScript:n,change:!0};d={txid:"",vout:o.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},o.addOutput(s)}return e.signer&&(o=await O(o,e.signer)),await o.fee(n),await o.sign(),d&&(d.satoshis=o.outputs[o.outputs.length-1].satoshis,d.txid=o.id("hex")),{tx:o,spentOutpoints:s,payChange:d}},P=async e=>{const{utxos:n,paymentPk:o,payments:s,satsPerKb:a=p,changeAddress:c=o.toAddress().toString()}=e,u=new i(a),f=new r;for(const e of s){const n={satoshis:e.amount,lockingScript:(new t).lock(e.to)};f.addOutput(n)}let d=0n;const l=f.outputs.reduce((t,e)=>t+(e.satoshis||0),0);let g,h=0;for(const e of n){const n=x(e,(new t).unlock(o));if(f.addInput(n),d+=BigInt(e.satoshis),h=await u.computeFee(f),d>=l+h)break}if(d<l+h)throw new Error(`Not enough funds to send. Total sats in: ${d}, Total sats out: ${l}, Fee: ${h}`);if(d>l+h){const e=(new t).lock(c),n={lockingScript:e,change:!0};g={txid:"",vout:f.outputs.length,satoshis:0,script:Buffer.from(e.toHex(),"hex").toString("base64")},f.addOutput(n)}else d<l+h&&console.log("No change needed");return await f.fee(u),await f.sign(),g&&(g.satoshis=f.outputs[f.outputs.length-1].satoshis,g.txid=f.id("hex")),{tx:f,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:g}},A=async t=>{const{protocol:e,tokenID:n,utxos:o,inputTokens:s,distributions:i,paymentPk:r,ordPk:a,changeAddress:c,tokenChangeAddress:u,satsPerKb:f=p,metaData:d,signer:l,additionalPayments:g=[],burn:h=!1}=t;let y=0n,b=0n,x=0n;if(!s.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of s)b+=BigInt(t.amt);for(const t of i)x+=BigInt(t.amt);if(b<x)throw new Error("Not enough tokens to send");if(y=b-x,y>0n){const t={address:u||a.toAddress().toString(),amt:y.toString()};i.push(t)}const k=i.map(t=>{const o={p:"bsv-20",op:h?"burn":"transfer",amt:t.amt};let s;if(e===m.BSV20)s=w({},o,{tick:n});else{if(e!==m.BSV21)throw new Error("Invalid protocol");s=w({},o,{id:n})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(s)).toString("base64"),contentType:"application/bsv-20"}}}),S={paymentUtxos:o,ordinals:s,paymentPk:r,ordPk:a,destinations:k,changeAddress:c||r.toAddress().toString(),satsPerKb:f,metaData:d,signer:l,additionalPayments:g,enforceUniformSend:!1},{tx:I,spentOutpoints:O,payChange:B}=await $(S),v=k.findIndex(t=>t.address===(u||a.toAddress().toString()));let P;return-1!==v&&(P={id:n,amt:y.toString(),satoshis:1,txid:I.id("hex"),vout:v,script:Buffer.from(I.outputs[v].lockingScript.toHex(),"hex").toString("base64")}),{tx:I,spentOutpoints:O,payChange:B,tokenChange:P}},E=(t,e)=>{try{if("collection"===t){const t=e;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(e=>"string"==typeof e&&"object"==typeof t.traits[e]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=e;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};class T{lock(e,s,i){const r=o.fromBase58Check(e).data,a=o.fromBase58Check(s).data;return n.fromHex("2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000").writeBin(r).writeBin(T.buildOutput(i,(new t).lock(a).toBinary())).writeScript(n.fromHex("615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868"))}cancelListing(e,n="all",o=!1,s,i){const r=(new t).unlock(e,n,o,s,i);return{sign:async function(t,e){return(await r.sign(t,e)).writeOpCode(a.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,e){const n={sign:async function(n,s){if(n.outputs.length<2)throw new Error("Malformed transaction");const i=(new u).writeBin(T.buildOutput(n.outputs[0].satoshis||0,n.outputs[0].lockingScript.toBinary()));if(n.outputs.length>2){const t=new o.Writer;for(const e of n.outputs.slice(2))t.write(T.buildOutput(e.satoshis||0,e.lockingScript.toBinary()));i.writeBin(t.toArray())}else i.writeOpCode(a.OP_0);const r=n.inputs[s],c=f.format({sourceTXID:r.sourceTXID||r.sourceTransaction.id("hex"),sourceOutputIndex:r.sourceOutputIndex,sourceSatoshis:t||r.sourceTransaction.outputs[r.sourceOutputIndex].satoshis,transactionVersion:n.version,otherInputs:[],inputIndex:s,outputs:n.outputs,inputSequence:r.sequence,subscript:e||r.sourceTransaction.outputs[r.sourceOutputIndex].lockingScript,lockTime:n.lockTime,scope:f.SIGHASH_ALL|f.SIGHASH_ANYONECANPAY|f.SIGHASH_FORKID});return i.writeBin(c).writeOpCode(a.OP_0)},estimateLength:async function(t,e){return(await n.sign(t,e)).toBinary().length}};return n}static buildOutput(t,e){const n=new o.Writer;return n.writeUInt64LEBn(new c(t)),n.writeVarIntNum(e.length),n.write(e),n.toArray()}}const{toArray:C}=o,N=async e=>{const{utxos:o,listings:s,paymentPk:a,ordPk:c,changeAddress:u,satsPerKb:f=p,additionalPayments:d=[]}=e,l=new i(f),g=new r;s.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of s){g.addOutput({satoshis:1,lockingScript:(new T).lock(t.payAddress,t.ordAddress,t.price)});const e=C(t.listingUtxo.script,"base64"),o=n.fromBinary(e);g.addInput({unlockingScriptTemplate:(new h).unlock(c,"all",!0,t.listingUtxo.satoshis,o),sourceTXID:t.listingUtxo.txid,sourceOutputIndex:t.listingUtxo.vout,sequence:4294967295})}for(const e of d)g.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});let w;const m=(new t).lock(u||a.toAddress().toString());g.addOutput({lockingScript:m,change:!0});let y=0n;const b=g.outputs.reduce((t,e)=>t+BigInt(e.satoshis||0),0n);let k=0;for(const e of o){const n=x(e,(new t).unlock(a));if(g.addInput(n),y+=BigInt(e.satoshis),k=await l.computeFee(g),y>=b+BigInt(k))break}if(y<b+BigInt(k))throw new Error(`Not enough funds to purchase listing. Total sats in: ${y}, Total sats out: ${b}, Fee: ${k}`);await g.fee(l),await g.sign();const S=g.outputs.findIndex(t=>t.change);if(-1!==S){const t=g.outputs[S];w={satoshis:t.satoshis,txid:g.id("hex"),vout:S,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return w&&(w.satoshis=g.outputs[g.outputs.length-1].satoshis,w.txid=g.id("hex")),{tx:g,spentOutpoints:g.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:w}},_=async e=>{const{utxos:o,listingUtxos:s,ordPk:a,paymentPk:c,changeAddress:u,additionalPayments:f,satsPerKb:d=p}=e,l=new i(d),g=new r;for(const e of s)g.addInput({unlockingScript:n.fromHex(Buffer.from(e.script,"base64").toString("hex")),unlockingScriptTemplate:(new T).cancelListing(a),sourceOutputIndex:e.vout,sequence:4294967295}),g.addOutput({satoshis:1,lockingScript:(new t).lock(a.toAddress().toString())});for(const e of f)g.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});let h;s.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const w=u||c.toAddress().toString(),m=(new t).lock(w);g.addOutput({lockingScript:m,change:!0});let y=0n;const b=g.outputs.reduce((t,e)=>t+BigInt(e.satoshis||0),0n);let k=0;for(const e of o){const n=x(e,(new t).unlock(c));if(g.addInput(n),y+=BigInt(e.satoshis),k=await l.computeFee(g),y>=b+BigInt(k))break}if(y<b+BigInt(k))throw new Error(`Not enough funds to purchase listing. Total sats in: ${y}, Total sats out: ${b}, Fee: ${k}`);await g.fee(l),await g.sign();const S=g.outputs.findIndex(t=>t.change);if(-1!==S){const t=g.outputs[S];h={satoshis:t.satoshis,txid:g.id("hex"),vout:S,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=g.outputs[g.outputs.length-1].satoshis,h.txid=g.id("hex")),{tx:g,spentOutpoints:g.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:h}},j=async e=>{const{utxos:o,paymentPk:s,listingUtxo:a,ordAddress:c,changeAddress:u,additionalPayments:f=[],satsPerKb:d=p}=e,l=new i(d),g=new r;g.addInput({unlockingScriptTemplate:(new T).purchaseListing(1,n.fromHex(Buffer.from(a.script,"base64").toString("hex"))),sourceTXID:a.txid,sourceOutputIndex:a.vout,sequence:4294967295}),g.addOutput({satoshis:1,lockingScript:(new t).lock(c)});for(const e of f)g.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});let h;const w=u||s.toAddress().toString(),m=(new t).lock(w);g.addOutput({lockingScript:m,change:!0});let y=0n;const b=g.outputs.reduce((t,e)=>t+BigInt(e.satoshis||0),0n);let k=0;for(const e of o){const n=x(e,(new t).unlock(s));if(g.addInput(n),y+=BigInt(e.satoshis),k=await l.computeFee(g),y>=b+BigInt(k))break}if(y<b+BigInt(k))throw new Error(`Not enough funds to purchase listing. Total sats in: ${y}, Total sats out: ${b}, Fee: ${k}`);await g.fee(l),await g.sign();const S=g.outputs.findIndex(t=>t.change);if(-1!==S){const t=g.outputs[S];h={satoshis:t.satoshis,txid:g.id("hex"),vout:S,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=g.outputs[g.outputs.length-1].satoshis,h.txid=g.id("hex")),{tx:g,spentOutpoints:g.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:h}};export{T as OrdLock,h as OrdP2PKH,y as RoytaltyType,m as TokenType,_ as cancelOrdListings,N as createOrdListings,v as createOrdinals,S as fetchNftUtxos,k as fetchPayUtxos,I as fetchTokenUtxos,j as purchaseOrdListings,$ as sendOrdinals,P as sendUtxos,B as stringifyMetaData,A as transferOrdTokens,E as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
