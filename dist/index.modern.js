import{P2PKH as n,LockingScript as t,fromUtxo as o,SatoshisPerKilobyte as e,Transaction as i}from"@bsv/sdk";import{Sigma as r}from"sigma-protocol";const s=n=>{const t=[];for(let o=0,e=n.length;o<e;o++){const e=Number(n.charCodeAt(o)).toString(16);t.push(e)}return t.join("")};class c extends n{lock(o,e,i,r){let c="";if(void 0!==e&&void 0!==i){const n=s("ord"),t=Buffer.from(e,"base64").toString("hex").trim();if(!t)throw new Error("Invalid file data");const o=s(i);if(!o)throw new Error("Invalid media type");c=`OP_0 OP_IF ${n} OP_1 ${o} OP_0 ${t} OP_ENDIF`}let a=`${c?`${c} `:""}${(new n).lock(o).toASM()}`;if(r&&(!r.app||!r.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=r&&r.app&&null!=r&&r.type){a=`${a} OP_RETURN ${s("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${s("SET")}`;for(const[n,t]of Object.entries(r))"cmd"!==n&&(a=`${a} ${s(n)} ${s(t)}`)}return t.fromASM(a)}}function a(){return a=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var e in o)({}).hasOwnProperty.call(o,e)&&(n[e]=o[e])}return n},a.apply(null,arguments)}const l=(n,t)=>{const e=o(a({},n,{script:Buffer.from(n.script,"base64").toString("hex")}),t);return e.sourceTXID=n.txid,e},d=async(t,o,s,a,d=10,u,p,f=[])=>{const w=new e(d);let g=new i;for(const o of t){const t=l(o,(new n).unlock(s));g.addInput(t)}o.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const n of o){if(!n.inscription)throw new Error("Inscription is required for all destinations");g.addOutput({satoshis:1,lockingScript:(new c).lock(n.address,n.inscription.dataB64,n.inscription.contentType,u)})}for(const t of f)g.addOutput({satoshis:t.amount,lockingScript:(new n).lock(t.to)});g.addOutput({lockingScript:(new n).lock(a),change:!0});const h=null==p?void 0:p.idKey,k=null==p?void 0:p.keyHost;if(h){const n=new r(g),{signedTx:t}=n.sign(h);g=t}else if(k){const n=null==p?void 0:p.authToken,t=new r(g);try{const{signedTx:o}=await t.remoteSign(k,n);g=o}catch(n){throw console.log(n),new Error(`Remote signing to ${k} failed`)}}return await g.fee(w),await g.sign(),g},u=async(t,o,r,s,a,d,u=10,p,f=[])=>{const w=new e(u),g=new i;for(const n of o){const t=l(n,(new c).unlock(a));g.addInput(t)}for(const o of t){const t=l(o,(new n).unlock(r));g.addInput(t)}if(d.length!==o.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const t of d){var h,k;let o;o=null!=(h=t.inscription)&&h.dataB64&&null!=(k=t.inscription)&&k.contentType?(new c).lock(t.address,t.inscription.dataB64,t.inscription.contentType,p):(new n).lock(t.address),g.addOutput({satoshis:1,lockingScript:o})}for(const t of f)g.addOutput({satoshis:t.amount,lockingScript:(new n).lock(t.to)});const m=(new n).lock(s);return g.addOutput({lockingScript:m,change:!0}),await g.fee(w),await g.sign(),g},p=async(t,o,r,s,c=10)=>{const a=new e(c),d=new i;for(const e of t){const t=l(e,(new n).unlock(o));d.addInput(t)}const u={satoshis:s,lockingScript:(new n).lock(r)};d.addOutput(u);const p=o.toAddress().toString(),f=(new n).lock(p);return d.addOutput({lockingScript:f,change:!0}),await d.fee(a),await d.sign(),d};export{d as createOrdinals,u as sendOrdinals,p as sendUtxos};
//# sourceMappingURL=index.modern.js.map
