import{P2PKH as t,LockingScript as n,Utils as o,fromUtxo as r,SatoshisPerKilobyte as e,Transaction as s}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const a=t=>Buffer.from(t).toString("hex"),c=10,d="https://ordinals.gorillapool.io/api";class u extends t{lock(o,r,e,s){let i="";if(void 0!==r&&void 0!==e){const t=a("ord"),n=Buffer.from(r,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=a(e);if(!o)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let c=`${i?`${i} `:""}${(new t).lock(o).toASM()}`;if(s&&(!s.app||!s.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=s&&s.app&&null!=s&&s.type){c=`${c} OP_RETURN ${a("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${a("SET")}`;for(const[t,n]of Object.entries(s))"cmd"!==t&&(c=`${c} ${a(t)} ${a(n)}`)}return n.fromASM(c)}}function l(){return l=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var r in o)({}).hasOwnProperty.call(o,r)&&(t[r]=o[r])}return t},l.apply(null,arguments)}var p,f;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(p||(p={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(f||(f={}));const{fromBase58Check:h}=o,g=(t,n)=>{const o=r(l({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return o.sourceTXID=t.txid,o},m=async n=>{const o=`${d}/txos/address/${n}/unspent?bsv20=false`;console.log({payUrl:o});const r=await fetch(o);if(!r.ok)throw new Error("Error fetching pay utxos");let e=await r.json();e=e.filter(t=>1!==t.satoshis);const s=h(n),i=(new t).lock(s.data);return e=e.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:Buffer.from(i.toBinary()).toString("base64")})),e},w=async(t,n,o=10,r=0)=>{let e=`${d}/txos/address/${t}/unspent?limit=${o}&offset=${r}&`;n&&(e+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:n}}})).toString("base64")}`),console.log({url:e});const s=await fetch(e);if(!s.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let i=await s.json();i=i.filter(t=>{var n;return 1===t.satoshis&&!(null!=(n=t.data)&&n.list)});const a=i.map(t=>`${t.txid}_${t.vout}`),c=await fetch(`${d}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...a])});if(!c.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return i=(await c.json()||[]).map(t=>{const o={origin:t.origin.outpoint,script:t.script,vout:t.vout,txid:t.txid,satoshis:1};return n&&(o.collectionId=n),o}),i},y=async(t,n,o)=>{const r=`${d}/bsv20/${o}/${t===p.BSV20?"tick":"id"}/${n}?bsv20=true&listing=false`;console.log({url:r});const e=await fetch(r);if(!e.ok)throw new Error(`Error fetching ${t} utxos`);let s=await e.json();return s=s.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:n,satoshis:1})),s},b=async(t,n)=>{const o=null==n?void 0:n.idKey,r=null==n?void 0:n.keyHost;if(o){const n=new i(t),{signedTx:r}=n.sign(o);return r}if(r){const o=null==n?void 0:n.authToken,e=new i(t);try{const{signedTx:t}=await e.remoteSign(r,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${r} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},k=t=>{if(!t)return;const n={app:t.app,type:t.type};for(const[o,r]of Object.entries(t))void 0!==r&&(n[o]="string"==typeof r?r:Array.isArray(r)||"object"==typeof r?JSON.stringify(r):String(r));return n},x=async n=>{const{utxos:o,destinations:r,paymentPk:i,changeAddress:a,satsPerKb:d=c,metaData:l,signer:p,additionalPayments:f=[]}=n,h=new e(d);let m=new s;for(const n of o){const o=g(n,(new t).unlock(i));m.addInput(o)}r.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of r){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(l)for(const t of Object.keys(l))void 0===l[t]&&delete l[t];m.addOutput({satoshis:1,lockingScript:(new u).lock(t.address,t.inscription.dataB64,t.inscription.contentType,k(l))})}for(const n of f)m.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});const w=o.reduce((t,n)=>t+BigInt(n.satoshis),0n),y=m.outputs.reduce((t,n)=>t+BigInt(n.satoshis||0),0n),x=await h.computeFee(m);let S;if(w>y+BigInt(x)){const n=(new t).lock(a||i.toAddress().toString()),o={lockingScript:n,change:!0};S={txid:"",vout:m.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},m.addOutput(o)}return p&&(m=await b(m,p)),await m.fee(h),await m.sign(),S&&(S.satoshis=m.outputs[m.outputs.length-1].satoshis,S.txid=m.id("hex")),{tx:m,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChange:S}},S=async n=>{n.satsPerKb||(n.satsPerKb=c),n.additionalPayments||(n.additionalPayments=[]),void 0===n.enforceUniformSend&&(n.enforceUniformSend=!0);const o=new e(n.satsPerKb);let r=new s;const i=[];for(const t of n.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const o=g(t,(new u).unlock(n.ordPk));i.push(`${t.txid}_${t.vout}`),r.addInput(o)}if(n.enforceUniformSend&&n.destinations.length!==n.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const o of n.destinations){var a,d;let e;e=null!=(a=o.inscription)&&a.dataB64&&null!=(d=o.inscription)&&d.contentType?(new u).lock(o.address,o.inscription.dataB64,o.inscription.contentType,k(n.metaData)):(new t).lock(o.address),r.addOutput({satoshis:1,lockingScript:e})}for(const o of n.additionalPayments)r.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let l=0n;const p=r.outputs.reduce((t,n)=>t+BigInt(n.satoshis||0),0n);let f,h=0;for(const e of n.paymentUtxos){const s=g(e,(new t).unlock(n.paymentPk));if(i.push(`${e.txid}_${e.vout}`),r.addInput(s),l+=BigInt(e.satoshis),h=await o.computeFee(r),l>=p+BigInt(h))break}if(l<p)throw new Error("Not enough ordinals to send");if(l>p+BigInt(h)){const o=(new t).lock(n.changeAddress||n.paymentPk.toAddress().toString()),e={lockingScript:o,change:!0};f={txid:"",vout:r.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},r.addOutput(e)}return n.signer&&(r=await b(r,n.signer)),await r.fee(o),await r.sign(),f&&(f.satoshis=r.outputs[r.outputs.length-1].satoshis,f.txid=r.id("hex")),{tx:r,spentOutpoints:i,payChange:f}},v=async n=>{const{utxos:o,paymentPk:r,payments:i,satsPerKb:a=c,changeAddress:d=r.toAddress().toString()}=n,u=new e(a),l=new s;for(const n of i){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};l.addOutput(o)}let p=0n;const f=l.outputs.reduce((t,n)=>t+(n.satoshis||0),0);let h,m=0;for(const n of o){const o=g(n,(new t).unlock(r));if(l.addInput(o),p+=BigInt(n.satoshis),m=await u.computeFee(l),p>=f+m)break}if(p<f+m)throw new Error(`Not enough funds to send. Total sats in: ${p}, Total sats out: ${f}, Fee: ${m}`);if(p>f+m){const n=(new t).lock(d),o={lockingScript:n,change:!0};h={txid:"",vout:l.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},l.addOutput(o)}else p<f+m&&console.log("No change needed");return await l.fee(u),await l.sign(),h&&(h.satoshis=l.outputs[l.outputs.length-1].satoshis,h.txid=l.id("hex")),{tx:l,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChange:h}},$=async t=>{const{protocol:n,tokenID:o,utxos:r,inputTokens:e,distributions:s,paymentPk:i,ordPk:a,changeAddress:d,tokenChangeAddress:u,satsPerKb:f=c,metaData:h,signer:g,additionalPayments:m=[]}=t;let w=0n,y=0n,b=0n;if(!e.every(t=>t.id===o))throw new Error("Input tokens do not match the provided tokenID");for(const t of e)y+=BigInt(t.amt);for(const t of s)b+=BigInt(t.amt);if(y<b)throw new Error("Not enough tokens to send");if(w=y-b,w>0n){const t={address:u||a.toAddress().toString(),amt:w.toString()};s.push(t)}const k=s.map(t=>{const r={p:"bsv-20",op:"transfer",amt:t.amt};let e;if(n===p.BSV20)e=l({},r,{tick:o});else{if(n!==p.BSV21)throw new Error("Invalid protocol");e=l({},r,{id:o})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv-20"}}}),x={paymentUtxos:r,ordinals:e,paymentPk:i,ordPk:a,destinations:k,changeAddress:d||i.toAddress().toString(),satsPerKb:f,metaData:h,signer:g,additionalPayments:m,enforceUniformSend:!1},{tx:v,spentOutpoints:$,payChange:E}=await S(x),I=k.findIndex(t=>t.address===(u||a.toAddress().toString()));let P;return-1!==I&&(P={id:o,amt:w.toString(),satoshis:1,txid:v.id("hex"),vout:I,script:Buffer.from(v.outputs[I].lockingScript.toHex(),"hex").toString("base64")}),{tx:v,spentOutpoints:$,payChange:E,tokenChange:P}},E=(t,n)=>{try{if("collection"===t){const t=n;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(({key:t,value:n})=>"string"==typeof t&&"string"==typeof n))return new Error("Invalid rarity labels")}if(!t.traits)return new Error("Collection traits are required")}if("collectionItem"===t){const t=n;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};export{u as OrdP2PKH,f as RoytaltyType,p as TokenType,x as createOrdinals,w as fetchNftUtxos,m as fetchPayUtxos,y as fetchTokenUtxos,S as sendOrdinals,v as sendUtxos,$ as transferOrdTokens,E as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
