import{P2PKH as t,LockingScript as o,Script as n,Utils as e,fromUtxo as s,SatoshisPerKilobyte as i,Transaction as r,OP as a,BigNumber as c,UnlockingScript as u,TransactionSignature as d}from"@bsv/sdk";import{Sigma as f}from"sigma-protocol";import l from"image-size";const p=t=>Buffer.from(t).toString("hex"),h="1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5",g=10,m="https://ordinals.gorillapool.io/api";class w extends t{lock(n,e,s){let i="";if(void 0!==(null==e?void 0:e.dataB64)&&void 0!==(null==e?void 0:e.contentType)){const t=p("ord"),o=Buffer.from(e.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=p(e.contentType);if(!n)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let r=`${i?`${i} `:""}${(new t).lock(n).toASM()}`;if(s&&(!s.app||!s.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=s&&s.app&&null!=s&&s.type){r=`${r?`${r} `:""}OP_RETURN ${p(h)} ${p("SET")}`;for(const[t,o]of Object.entries(s))"cmd"!==t&&(r=`${r} ${p(t)} ${p(o)}`)}return o.fromASM(r)}}function y(){return y=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var e in n)({}).hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},y.apply(null,arguments)}var b,k,S,I;!function(t){t.SmallestFirst="smallest",t.LargestFirst="largest",t.RetainOrder="retain",t.Random="random"}(b||(b={})),function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(k||(k={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(S||(S={})),function(t){t.All="all",t.Needed="needed"}(I||(I={}));const B=2n**64n-1n,{fromBase58Check:x}=e,v=(t,o)=>s(y({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o),O=async(o,n="base64")=>{const e=`${m}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:e});const s=await fetch(e);if(!s.ok)throw new Error("Error fetching pay utxos");let i=await s.json();i=i.filter(t=>1!==t.satoshis&&!E(t));const r=x(o),a=(new t).lock(r.data);return i=i.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===n||"base64"===n?Buffer.from(a.toBinary()).toString(n):a.toASM()})),i},$=async(t,o,e=10,s=0,i="base64")=>{let r=`${m}/txos/address/${t}/unspent?limit=${e}&offset=${s}&`;o&&(r+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const a=await fetch(r);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const u=c.map(t=>`${t.txid}_${t.vout}`),d=await fetch(`${m}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...u])});if(!d.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await d.json()||[]).map(t=>{let e=t.script;"hex"===i?e=Buffer.from(e,"base64").toString("hex"):"asm"===i&&(e=n.fromHex(Buffer.from(e,"base64").toString("hex")).toASM());const s={origin:t.origin.outpoint,script:e,vout:t.vout,txid:t.txid,satoshis:1};return o&&(s.collectionId=o),s}),c},A=async(t,o,n,e=10,s=0)=>{const i=`${m}/bsv20/${n}/${t===k.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false&limit=${e}&offset=${s}`,r=await fetch(i);if(!r.ok)throw new Error(`Error fetching ${t} utxos`);let a=await r.json();return a=a.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),a},E=t=>!!t.lock,P=(t,o,n,e={})=>{const{inputStrategy:s=b.RetainOrder,outputStrategy:i=b.RetainOrder}=e,r=BigInt(Math.floor(o*10**n)),a=[...t].sort((t,o)=>{if(s===b.RetainOrder)return 0;const n=BigInt(t.amt),e=BigInt(o.amt);switch(s){case b.SmallestFirst:return Number(n-e);case b.LargestFirst:return Number(e-n);case b.Random:return Math.random()-.5;default:return 0}});let c=0n;const u=[];for(const t of a)if(u.push(t),c+=BigInt(t.amt),c>=r&&r>0n)break;return i!==b.RetainOrder&&u.sort((t,o)=>{const n=BigInt(t.amt),e=BigInt(o.amt);switch(i){case b.SmallestFirst:return Number(n-e);case b.LargestFirst:return Number(e-n);case b.Random:return Math.random()-.5;default:return 0}}),{selectedUtxos:u,totalSelected:c,isEnough:c>=r}},N=async(t,o)=>{const n=null==o?void 0:o.idKey,e=null==o?void 0:o.keyHost;if(n){const o=new f(t),{signedTx:e}=o.sign(n);return e}if(e){const n=null==o?void 0:o.authToken,s=new f(t);try{const{signedTx:t}=await s.remoteSign(e,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},T=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[n,e]of Object.entries(t))void 0!==e&&(o[n]="string"==typeof e?e:Array.isArray(e)||"object"==typeof e?JSON.stringify(e):String(e));return o},_=async o=>{const{utxos:s,destinations:a,paymentPk:c,changeAddress:u,satsPerKb:d=g,metaData:f,signer:l,additionalPayments:p=[]}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const h=new i(d);let m,y=new r;for(const t of a){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(f)for(const t of Object.keys(f))void 0===f[t]&&delete f[t];y.addOutput({satoshis:1,lockingScript:(new w).lock(t.address,t.inscription,T(f))})}for(const o of p)y.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const b=u||c.toAddress().toString(),k=(new t).lock(b);y.addOutput({lockingScript:k,change:!0});let S=0n;const I=y.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);if(l){const o=s.pop();y.addInput(v(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))))),S+=BigInt(o.satoshis),y=await N(y,l)}let B=0;for(const o of s){if(S>=I+BigInt(B))break;const s=v(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));y.addInput(s),S+=BigInt(o.satoshis),B=await h.computeFee(y)}if(S<I+BigInt(B))throw new Error(`Not enough funds to create ordinals. Total sats in: ${S}, Total sats out: ${I}, Fee: ${B}`);await y.fee(h),await y.sign();const x=y.outputs.findIndex(t=>t.change);if(-1!==x){const t=y.outputs[x];m={satoshis:t.satoshis,txid:y.id("hex"),vout:x,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=y.outputs[y.outputs.length-1].satoshis,m.txid=y.id("hex")),{tx:y,spentOutpoints:s.map(t=>`${t.txid}_${t.vout}`),payChange:m}},C=async o=>{o.satsPerKb||(o.satsPerKb=g),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const s=new i(o.satsPerKb);let a=new r;const c=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const s=v(t,(new w).unlock(o.ordPk,"all",!0,t.satoshis,n.fromBinary(e.toArray(t.script,"base64"))));c.push(`${t.txid}_${t.vout}`),a.addInput(s)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of o.destinations){var u,d;let e;e=null!=(u=n.inscription)&&u.dataB64&&null!=(d=n.inscription)&&d.contentType?(new w).lock(n.address,n.inscription,T(o.metaData)):(new t).lock(n.address),a.addOutput({satoshis:1,lockingScript:e})}for(const n of o.additionalPayments)a.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});let f;const l=o.changeAddress||o.paymentPk.toAddress().toString(),p=(new t).lock(l);a.addOutput({lockingScript:p,change:!0});let h=0n;const m=a.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let y=0;for(const i of o.paymentUtxos){const r=v(i,(new t).unlock(o.paymentPk,"all",!0,i.satoshis,n.fromBinary(e.toArray(i.script,"base64"))));if(c.push(`${i.txid}_${i.vout}`),a.addInput(r),h+=BigInt(i.satoshis),y=await s.computeFee(a),h>=m+BigInt(y))break}if(h<m)throw new Error("Not enough ordinals to send");o.signer&&(a=await N(a,o.signer)),await a.fee(s),await a.sign();const b=a.outputs.findIndex(t=>t.change);if(-1!==b){const t=a.outputs[b];f={satoshis:t.satoshis,txid:a.id("hex"),vout:b,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return f&&(f.satoshis=a.outputs[a.outputs.length-1].satoshis,f.txid=a.id("hex")),{tx:a,spentOutpoints:c,payChange:f}},F=async o=>{const{utxos:s,paymentPk:a,payments:c,satsPerKb:u=g,changeAddress:d=a.toAddress().toString(),metaData:f}=o,l=new i(u),p=new r;for(const t of c){const o={satoshis:t.amount,lockingScript:(new w).lock(t.to,void 0,f)};p.addOutput(o)}let h=0n;const m=p.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let y,b=0;for(const o of s){const s=v(o,(new t).unlock(a,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(p.addInput(s),h+=BigInt(o.satoshis),b=await l.computeFee(p),h>=m+b)break}if(h<m+b)throw new Error(`Not enough funds to send. Total sats in: ${h}, Total sats out: ${m}, Fee: ${b}`);if(h>m+b){const o=(new t).lock(d),n={lockingScript:o,change:!0};y={txid:"",vout:p.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},p.addOutput(n)}else h<m+b&&console.log("No change needed");await p.fee(l),await p.sign();const k=p.outputs.findIndex(t=>t.change);if(-1!==k){const t=p.outputs[k];y={satoshis:t.satoshis,txid:p.id("hex"),vout:k,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return y&&(y.satoshis=p.outputs[p.outputs.length-1].satoshis,y.txid=p.id("hex")),{tx:p,spentOutpoints:s.map(t=>`${t.txid}_${t.vout}`),payChange:y}},D=async o=>{const{protocol:s,tokenID:a,utxos:c,inputTokens:u,distributions:d,paymentPk:f,ordPk:l,changeAddress:p,tokenChangeAddress:h,satsPerKb:m=g,metaData:b,signer:S,decimals:B,additionalPayments:x=[],burn:O=!1,tokenInputMode:$=I.Needed,splitConfig:A={outputs:1,omitMetaData:!1}}=o;if(!u.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");let E=0n,P=0n,_=0n;const C=d.reduce((t,o)=>t+BigInt(o.amt*10**B),0n),F=new i(m);let D,M=new r;if($===I.All)D=u,P=u.reduce((t,o)=>t+BigInt(o.amt),0n);else{D=[];for(const t of u)if(D.push(t),P+=BigInt(t.amt),P>=C)break;if(P<C)throw new Error("Not enough tokens to satisfy the transfer amount")}for(const t of D){const o=e.toArray(t.script,"base64"),s=n.fromBinary(o);M.addInput(v(t,(new w).unlock(l,"all",!0,t.satoshis,s)))}if(b)for(const t of Object.keys(b))void 0===b[t]&&delete b[t];for(const t of d){const o=BigInt(t.amt*10**B),n={p:"bsv-20",op:O?"burn":"transfer",amt:o.toString()};let e;if(s===k.BSV20)e=y({},n,{tick:a});else{if(s!==k.BSV21)throw new Error("Invalid protocol");e=y({},n,{id:a})}M.addOutput({satoshis:1,lockingScript:(new w).lock(t.address,{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv-20"},t.omitMetaData?void 0:T(b))}),_+=o}if(E=P-_,console.log({changeAmt:E,totalAmtIn:P,totalAmtOut:_}),E<0n)throw new Error("Not enough tokens to send");let R,U=[];E>0n&&(U=L(M,E,s,a,h||l.toAddress().toString(),l,b,A));for(const o of x)M.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const j=p||f.toAddress().toString(),V=(new t).lock(j);M.addOutput({lockingScript:V,change:!0});let K=0n;const q=M.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let H=0;for(const o of c){const s=v(o,(new t).unlock(f,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(M.addInput(s),K+=BigInt(o.satoshis),H=await F.computeFee(M),K>=q+BigInt(H))break}if(K<q+BigInt(H))throw new Error(`Not enough funds to transfer tokens. Total sats in: ${K}, Total sats out: ${q}, Fee: ${H}`);S&&(M=await N(M,S)),await M.fee(F),await M.sign();const J=M.id("hex");for(const t of U)t.txid=J;const X=M.outputs.findIndex(t=>t.change);if(-1!==X){const t=M.outputs[X];R={satoshis:t.satoshis,txid:J,vout:X,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return R&&(R.satoshis=M.outputs[M.outputs.length-1].satoshis,R.txid=M.id("hex")),{tx:M,spentOutpoints:M.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:R,tokenChange:U}},L=(t,o,n,e,s,i,r,a)=>{const c=[],u=BigInt(a.threshold||0),d=a.outputs;let f=1;u>0n&&(f=Number(o/u),f=Math.min(f,d),f=Math.max(f,1));const l=o/BigInt(f);let p=o%BigInt(f);for(let o=0;o<f;o++){let o=l;p>0n&&(o+=1n,p-=1n);const u={p:"bsv-20",op:"transfer",amt:o.toString()};let d;if(n===k.BSV20)d=y({},u,{tick:e});else{if(n!==k.BSV21)throw new Error("Invalid protocol");d=y({},u,{id:e})}const f=(new w).lock(s||i.toAddress().toString(),{dataB64:Buffer.from(JSON.stringify(d)).toString("base64"),contentType:"application/bsv-20"},a.omitMetaData?void 0:T(r)),h=t.outputs.length;t.addOutput({lockingScript:f,satoshis:1}),c.push({id:e,satoshis:1,script:Buffer.from(f.toBinary()).toString("base64"),txid:"",vout:h,amt:o.toString()})}return c},M=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};class R{lock(o,s,i,r){const a=e.fromBase58Check(o).data,c=e.fromBase58Check(s).data;let u=new n;if(void 0!==(null==r?void 0:r.dataB64)&&void 0!==(null==r?void 0:r.contentType)){const t=p("ord"),o=Buffer.from(r.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const e=p(r.contentType);if(!e)throw new Error("Invalid media type");u=n.fromASM(`OP_0 OP_IF ${t} OP_1 ${e} OP_0 ${o} OP_ENDIF`)}return u.writeScript(n.fromHex("2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000")).writeBin(a).writeBin(R.buildOutput(i,(new t).lock(c).toBinary())).writeScript(n.fromHex("615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868"))}cancelListing(o,n="all",e=!1,s,i){const r=(new t).unlock(o,n,e,s,i);return{sign:async function(t,o){return(await r.sign(t,o)).writeOpCode(a.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,o){const n={sign:async function(n,s){var i;if(n.outputs.length<2)throw new Error("Malformed transaction");const r=(new u).writeBin(R.buildOutput(n.outputs[0].satoshis||0,n.outputs[0].lockingScript.toBinary()));if(n.outputs.length>2){const t=new e.Writer;for(const o of n.outputs.slice(2))t.write(R.buildOutput(o.satoshis||0,o.lockingScript.toBinary()));r.writeBin(t.toArray())}else r.writeOpCode(a.OP_0);const c=n.inputs[s];let f=t;if(!f&&c.sourceTransaction)f=c.sourceTransaction.outputs[c.sourceOutputIndex].satoshis;else if(!t)throw new Error("sourceTransaction or sourceSatoshis is required");const l=c.sourceTXID||(null==(i=c.sourceTransaction)?void 0:i.id("hex"));let p=o;var h;p||(p=null==(h=c.sourceTransaction)?void 0:h.outputs[c.sourceOutputIndex].lockingScript);const g=d.format({sourceTXID:l,sourceOutputIndex:c.sourceOutputIndex,sourceSatoshis:f,transactionVersion:n.version,otherInputs:[],inputIndex:s,outputs:n.outputs,inputSequence:c.sequence,subscript:p,lockTime:n.lockTime,scope:d.SIGHASH_ALL|d.SIGHASH_ANYONECANPAY|d.SIGHASH_FORKID});return r.writeBin(g).writeOpCode(a.OP_0)},estimateLength:async function(t,o){return(await n.sign(t,o)).toBinary().length}};return n}static buildOutput(t,o){const n=new e.Writer;return n.writeUInt64LEBn(new c(t)),n.writeVarIntNum(o.length),n.write(o),n.toArray()}}const{toArray:U}=e,j=async o=>{const{utxos:s,listings:a,paymentPk:c,ordPk:u,changeAddress:d,satsPerKb:f=g,additionalPayments:l=[]}=o,p=new i(f),h=new r;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of a){h.addOutput({satoshis:1,lockingScript:(new R).lock(t.ordAddress,t.payAddress,t.price)});const o=U(t.listingUtxo.script,"base64"),e=n.fromBinary(o);h.addInput(v(t.listingUtxo,(new w).unlock(u,"all",!0,t.listingUtxo.satoshis,e)))}for(const o of l)h.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let m;const y=(new t).lock(d||c.toAddress().toString());h.addOutput({lockingScript:y,change:!0});let b=0n;const k=h.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let S=0;for(const o of s){const s=v(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(h.addInput(s),b+=BigInt(o.satoshis),S=await p.computeFee(h),b>=k+BigInt(S))break}if(b<k+BigInt(S))throw new Error(`Not enough funds to create ordinal listings. Total sats in: ${b}, Total sats out: ${k}, Fee: ${S}`);await h.fee(p),await h.sign();const I=h.outputs.findIndex(t=>t.change);if(-1!==I){const t=h.outputs[I];m={satoshis:t.satoshis,txid:h.id("hex"),vout:I,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=h.outputs[h.outputs.length-1].satoshis,m.txid=h.id("hex")),{tx:h,spentOutpoints:h.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:m}},V=async o=>{const{utxos:s,protocol:a,tokenID:c,ordPk:u,paymentPk:d,additionalPayments:f=[],changeAddress:l,tokenChangeAddress:p,inputTokens:h,listings:m,decimals:b,satsPerKb:S=g}=o;if(m.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!h.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");let I=0n,B=0n,x=0n;if(!h.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");const O=new i(S),$=new r;for(const t of m){const o=BigInt(t.amt*10**b),n={p:"bsv-20",op:"transfer",amt:o.toString()};let e;if(a===k.BSV20)e=y({},n,{tick:c});else{if(a!==k.BSV21)throw new Error("Invalid protocol");e=y({},n,{id:c})}$.addOutput({satoshis:1,lockingScript:(new R).lock(t.ordAddress,t.payAddress,t.price,{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv-20"})}),x+=o}for(const t of h)$.addInput(v(t,(new w).unlock(u,"all",!0,t.satoshis,n.fromBinary(U(t.script,"base64"))))),B+=BigInt(t.amt);let A,E;if(I=B-x,I<0n)throw new Error("Not enough tokens to send");if(I>0n){const t={p:"bsv-20",op:"transfer",amt:I.toString()};let o;if(a===k.BSV20)o=y({},t,{tick:c});else{if(a!==k.BSV21)throw new Error("Invalid protocol");o=y({},t,{id:c})}const n=(new w).lock(p,{dataB64:Buffer.from(JSON.stringify(o)).toString("base64"),contentType:"application/bsv-20"}),e=$.outputs.length;$.addOutput({lockingScript:n,satoshis:1}),A=[{id:c,satoshis:1,script:Buffer.from(n.toBinary()).toString("base64"),txid:"",vout:e,amt:I.toString()}]}for(const o of f)$.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const P=l||d.toAddress().toString(),N=(new t).lock(P);$.addOutput({lockingScript:N,change:!0});let T=0n;const _=$.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let C=0;for(const o of s){const s=v(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if($.addInput(s),T+=BigInt(o.satoshis),C=await O.computeFee($),T>=_+BigInt(C))break}if(T<_+BigInt(C))throw new Error(`Not enough funds to create token listings. Total sats in: ${T}, Total sats out: ${_}, Fee: ${C}`);await $.fee(O),await $.sign();const F=$.id("hex");A&&(A=A.map(t=>y({},t,{txid:F})));const D=$.outputs.findIndex(t=>t.change);if(-1!==D){const t=$.outputs[D];E={satoshis:t.satoshis,txid:F,vout:D,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return E&&(E.satoshis=$.outputs[$.outputs.length-1].satoshis,E.txid=$.id("hex")),{tx:$,spentOutpoints:$.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:E,tokenChange:A}},K=async o=>{const{utxos:s,listingUtxos:a,ordPk:c,paymentPk:u,changeAddress:d,additionalPayments:f=[],satsPerKb:l=g}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const p=new i(l),h=new r;for(const o of a)h.addInput(v(o,(new R).cancelListing(c,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))))),h.addOutput({satoshis:1,lockingScript:(new t).lock(c.toAddress().toString())});for(const o of f)h.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let m;const w=d||u.toAddress().toString(),y=(new t).lock(w);h.addOutput({lockingScript:y,change:!0});let b=0n;const k=h.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let S=0;for(const o of s){const s=v(o,(new t).unlock(u,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(h.addInput(s),b+=BigInt(o.satoshis),S=await p.computeFee(h),b>=k+BigInt(S))break}if(b<k+BigInt(S))throw new Error(`Not enough funds to cancel ordinal listings. Total sats in: ${b}, Total sats out: ${k}, Fee: ${S}`);await h.fee(p),await h.sign();const I=h.outputs.findIndex(t=>t.change);if(-1!==I){const t=h.outputs[I];m={satoshis:t.satoshis,txid:h.id("hex"),vout:I,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=h.outputs[h.outputs.length-1].satoshis,m.txid=h.id("hex")),{tx:h,spentOutpoints:h.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:m}},q=async o=>{const{protocol:s,tokenID:a,ordAddress:c,changeAddress:u,paymentPk:d,ordPk:f,additionalPayments:l,listingUtxos:p,utxos:h,satsPerKb:m=g}=o;let b=0;if(p.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!p.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");const S=new i(m),I=new r;for(const t of p)I.addInput(v(t,(new R).cancelListing(f,"all",!0,t.satoshis,n.fromBinary(e.toArray(t.script,"base64"))))),b+=Number.parseInt(t.amt);const B={p:"bsv-20",op:"transfer",amt:b.toString()};let x;if(s===k.BSV20)x=y({},B,{tick:a});else{if(s!==k.BSV21)throw new Error("Invalid protocol");x=y({},B,{id:a})}const O={address:c||f.toAddress().toString(),inscription:{dataB64:Buffer.from(JSON.stringify(x)).toString("base64"),contentType:"application/bsv-20"}},$=(new w).lock(O.address,O.inscription);I.addOutput({satoshis:1,lockingScript:$});for(const o of l)I.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let A;const E=u||d.toAddress().toString(),P=(new t).lock(E);I.addOutput({lockingScript:P,change:!0});let N=0n;const T=I.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let _=0;for(const o of h){const s=v(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(I.addInput(s),N+=BigInt(o.satoshis),_=await S.computeFee(I),N>=T+BigInt(_))break}if(N<T+BigInt(_))throw new Error(`Not enough funds to cancel token listings. Total sats in: ${N}, Total sats out: ${T}, Fee: ${_}`);await I.fee(S),await I.sign();const C=[{amt:b.toString(),script:Buffer.from($.toHex(),"hex").toString("base64"),txid:I.id("hex"),vout:0,id:a,satoshis:1}],F=I.outputs.findIndex(t=>t.change);if(-1!==F){const t=I.outputs[F];A={satoshis:t.satoshis,txid:I.id("hex"),vout:F,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return A&&(A.satoshis=I.outputs[I.outputs.length-1].satoshis,A.txid=I.id("hex")),{tx:I,spentOutpoints:I.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:A,tokenChange:C}},H=async(t,o)=>{throw new Error("Not implemented")},J=async s=>{const{utxos:a,paymentPk:c,listing:u,ordAddress:d,changeAddress:f,additionalPayments:l=[],satsPerKb:p=g,royalties:h=[],metaData:m}=s,y=new i(p),b=new r;b.addInput(v(u.listingUtxo,(new R).purchaseListing(1,n.fromBinary(e.toArray(u.listingUtxo.script,"base64"))))),b.addOutput({satoshis:1,lockingScript:(new w).lock(d,void 0,m)});const k=new e.Reader(e.toArray(u.payout,"base64")),I=k.readUInt64LEBn().toNumber(),B=k.readVarIntNum(),x=k.read(B),O=o.fromBinary(x);b.addOutput({satoshis:I,lockingScript:O});for(const o of l)b.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});for(const o of h){let s;const i=Math.floor(Number(o.percentage)*I);switch(o.type){case S.Paymail:s=await H();break;case S.Script:s=n.fromBinary(e.toArray(o.destination,"base64"));break;case S.Address:s=(new t).lock(o.destination);break;default:throw new Error("Invalid royalty type")}if(!s)throw new Error("Invalid royalty destination");b.addOutput({satoshis:i,lockingScript:s})}let $;const A=f||c.toAddress().toString(),E=(new t).lock(A);b.addOutput({lockingScript:E,change:!0});let P=0n;const N=b.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let T=0;for(const o of a){const s=v(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(b.addInput(s),P+=BigInt(o.satoshis),T=await y.computeFee(b),P>=N+BigInt(T))break}if(P<N+BigInt(T))throw new Error(`Not enough funds to purchase ordinal listing. Total sats in: ${P}, Total sats out: ${N}, Fee: ${T}`);await b.fee(y),await b.sign();const _=b.outputs.findIndex(t=>t.change);if(-1!==_){const t=b.outputs[_];$={satoshis:t.satoshis,txid:b.id("hex"),vout:_,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return $&&($.satoshis=b.outputs[b.outputs.length-1].satoshis,$.txid=b.id("hex")),{tx:b,spentOutpoints:b.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:$}},X=async s=>{const{protocol:a,tokenID:c,utxos:u,paymentPk:d,listingUtxo:f,ordAddress:l,changeAddress:p,satsPerKb:h=g,additionalPayments:m=[],metaData:b}=s,S=new i(h),I=new r;I.addInput(v(f,(new R).purchaseListing(1,n.fromBinary(e.toArray(f.script,"base64")))));const B={p:"bsv-20",op:"transfer",amt:f.amt};let x;if(a===k.BSV20)x=y({},B,{tick:c});else{if(a!==k.BSV21)throw new Error("Invalid protocol");x=y({},B,{id:c})}const O=Buffer.from(JSON.stringify(x)).toString("base64");if(I.addOutput({satoshis:1,lockingScript:(new w).lock(l,{dataB64:O,contentType:"application/bsv-20"},b)}),!f.payout)throw new Error("Listing UTXO does not have a payout script");const $=new e.Reader(e.toArray(f.payout,"base64")),A=$.readUInt64LEBn().toNumber(),E=$.readVarIntNum(),P=$.read(E),N=o.fromBinary(P);I.addOutput({satoshis:A,lockingScript:N});for(const o of m)I.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let T;const _=p||d.toAddress().toString(),C=(new t).lock(_);I.addOutput({lockingScript:C,change:!0});let F=0n;const D=I.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let L=0;for(const o of u){const s=v(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(I.addInput(s),F+=BigInt(o.satoshis),L=await S.computeFee(I),F>=D+BigInt(L))break}if(F<D+BigInt(L))throw new Error(`Not enough funds to purchase token listing. Total sats in: ${F}, Total sats out: ${D}, Fee: ${L}`);await I.fee(S),await I.sign();const M=I.outputs.findIndex(t=>t.change);if(-1!==M){const t=I.outputs[M];T={satoshis:t.satoshis,txid:I.id("hex"),vout:M,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return T&&(T.satoshis=I.outputs[I.outputs.length-1].satoshis,T.txid=I.id("hex")),{tx:I,spentOutpoints:I.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:T}},W=new Error("Image must be a square image with dimensions <= 400x400"),G=new Error("Image must be a square image"),Y=new Error("Error processing image"),z=new Error("Image dimensions are undefined"),Q=async o=>{const{symbol:s,icon:a,decimals:c,utxos:u,initialDistribution:d,paymentPk:f,destinationAddress:p,changeAddress:h,satsPerKb:m=g,additionalPayments:y=[]}=o,b=new i(m),k=new r;let S;if("string"==typeof a)S=a;else{const t=await(async t=>{const{dataB64:o,contentType:n}=t;if("image/svg+xml"===n)return(t=>{const o=Buffer.from(t,"base64").toString("utf-8"),n=o.match(/<svg[^>]*\s+width="([^"]+)"/),e=o.match(/<svg[^>]*\s+height="([^"]+)"/);if(!n||!e)return z;const s=Number.parseInt(n[1],10),i=Number.parseInt(e[1],10);return Number.isNaN(s)||Number.isNaN(i)?z:s!==i?G:s>400||i>400?W:null})(o);if((e=n)!=e)return Y;var e;try{const t=Buffer.from(o,"base64"),n=l(t);return void 0===n.width||void 0===n.height?z:n.width!==n.height?G:n.width>400||n.height>400?W:null}catch(t){return Y}})(a);if(t)throw t;const o=(new w).lock(p,a);k.addOutput({satoshis:1,lockingScript:o}),S="_0"}if(!(t=>{if(!t.includes("_")||t.endsWith("_"))return!1;const o=Number.parseInt(t.split("_")[1]);return!(Number.isNaN(o)||!t.startsWith("_")&&64!==t.split("_")[0].length)})(S))throw new Error("Invalid icon format. Must be either outpoint (format: txid_vout) or relative output index of the icon (format _vout). examples: ecb483eda58f26da1b1f8f15b782b1186abdf9c6399a1c3e63e0d429d5092a41_0 or _1");const I={p:"bsv-20",op:"deploy+mint",sym:s,icon:S,amt:(c?BigInt(d.amt)*10n**BigInt(c):BigInt(d.amt)).toString()};c&&(I.dec=c.toString());const B=Buffer.from(JSON.stringify(I)).toString("base64"),x={satoshis:1,lockingScript:(new w).lock(p,{dataB64:B,contentType:"application/bsv-20"})};k.addOutput(x);for(const o of y){const n={satoshis:o.amount,lockingScript:(new t).lock(o.to)};k.addOutput(n)}let O=0n;const $=k.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let A,E=0;for(const o of u){const s=v(o,(new t).unlock(f,"all",!0,o.satoshis,n.fromBinary(e.toArray(o.script,"base64"))));if(k.addInput(s),O+=BigInt(o.satoshis),E=await b.computeFee(k),O>=$+BigInt(E))break}if(O<$+BigInt(E))throw new Error(`Not enough funds to deploy token. Total sats in: ${O}, Total sats out: ${$}, Fee: ${E}`);const P=h||f.toAddress().toString(),N=(new t).lock(P);k.addOutput({lockingScript:N,change:!0}),await k.fee(b),await k.sign();const T=k.outputs.findIndex(t=>t.change);if(-1!==T){const t=k.outputs[T];A={satoshis:t.satoshis,txid:k.id("hex"),vout:T,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return{tx:k,spentOutpoints:k.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:A}},Z=async t=>{const o=new r,s=[],{ordinals:i,metaData:a}=t;for(const r of i){if(1!==r.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const i=v(r,(new w).unlock(t.ordPk,"all",!0,r.satoshis,n.fromBinary(e.toArray(r.script,"base64"))));s.push(`${r.txid}_${r.vout}`),o.addInput(i)}if(a&&(!a.app||!a.type))throw new Error("MAP.app and MAP.type are required fields");let c="";if(null!=a&&a.app&&null!=a&&a.type){c=`OP_FALSE OP_RETURN ${p(h)} ${p("SET")}`;for(const[t,o]of Object.entries(a))"cmd"!==t&&(c=`${c} ${p(t)} ${p(o)}`)}return o.addOutput({satoshis:0,lockingScript:n.fromASM(c||"OP_FALSE OP_RETURN")}),await o.sign(),{tx:o,spentOutpoints:s}};export{B as MAX_TOKEN_SUPPLY,R as OrdLock,w as OrdP2PKH,S as RoytaltyType,I as TokenInputMode,b as TokenSelectionStrategy,k as TokenType,Z as burnOrdinals,K as cancelOrdListings,q as cancelOrdTokenListings,j as createOrdListings,V as createOrdTokenListings,_ as createOrdinals,Q as deployBsv21Token,$ as fetchNftUtxos,O as fetchPayUtxos,A as fetchTokenUtxos,J as purchaseOrdListing,X as purchaseOrdTokenListing,P as selectTokenUtxos,C as sendOrdinals,F as sendUtxos,T as stringifyMetaData,D as transferOrdTokens,M as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
