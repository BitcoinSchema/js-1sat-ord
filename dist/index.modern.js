import{P2PKH as t,LockingScript as n,Utils as o,fromUtxo as e,SatoshisPerKilobyte as s,Transaction as r}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const a=t=>Buffer.from(t).toString("hex"),d=10;class c extends t{lock(o,e,s,r){let i="";if(void 0!==e&&void 0!==s){const t=a("ord"),n=Buffer.from(e,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=a(s);if(!o)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let d=`${i?`${i} `:""}${(new t).lock(o).toASM()}`;if(r&&(!r.app||!r.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=r&&r.app&&null!=r&&r.type){d=`${d} OP_RETURN ${a("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${a("SET")}`;for(const[t,n]of Object.entries(r))"cmd"!==t&&(d=`${d} ${a(t)} ${a(n)}`)}return n.fromASM(d)}}function u(){return u=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var e in o)({}).hasOwnProperty.call(o,e)&&(t[e]=o[e])}return t},u.apply(null,arguments)}const{fromBase58Check:l}=o,p=(t,n)=>{const o=e(u({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return o.sourceTXID=t.txid,o},f=async n=>{const o=`https://ordinals.gorillapool.io/api/txos/address/${n}/unspent?bsv20=false`;console.log({payUrl:o});const e=await fetch(o);if(!e.ok)return void console.error("Error fetching pay utxos:",e.statusText);let s=await e.json();s=s.filter(t=>1!==t.satoshis);const r=l(n),i=(new t).lock(r.data);return s=s.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:Buffer.from(i.toBinary()).toString("base64")})),s},g=async(t,n)=>{const o=null==n?void 0:n.idKey,e=null==n?void 0:n.keyHost;if(o){const n=new i(t),{signedTx:e}=n.sign(o);return e}if(e){const o=null==n?void 0:n.authToken,s=new i(t);try{const{signedTx:t}=await s.remoteSign(e,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},h=async n=>{const{utxos:o,destinations:e,paymentPk:i,changeAddress:a,satsPerKb:u=d,metaData:l,signer:f,additionalPayments:h=[]}=n,m=new s(u);let w,y=new r;for(const n of o){const o=p(n,(new t).unlock(i));y.addInput(o)}e.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of e){if(!t.inscription)throw new Error("Inscription is required for all destinations");y.addOutput({satoshis:1,lockingScript:(new c).lock(t.address,t.inscription.dataB64,t.inscription.contentType,l)})}for(const n of h)y.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});const k=o.reduce((t,n)=>t+BigInt(n.satoshis),0n),S=y.outputs.reduce((t,n)=>t+BigInt(n.satoshis||0),0n),P=await m.computeFee(y);return k>S+BigInt(P)&&(y.addOutput({lockingScript:(new t).lock(a||i.toAddress().toString()),change:!0}),w=y.outputs.length-1),f&&(y=await g(y,f)),await y.fee(m),await y.sign(),{tx:y,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChangeVout:w}},m=async n=>{n.satsPerKb||(n.satsPerKb=d),n.additionalPayments||(n.additionalPayments=[]),void 0===n.enforceUniformSend&&(n.enforceUniformSend=!0);const o=new s(n.satsPerKb);let e=new r;const i=[];let a;for(const t of n.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const o=p(t,(new c).unlock(n.ordPk));i.push(`${t.txid}_${t.vout}`),e.addInput(o)}if(n.enforceUniformSend&&n.destinations.length!==n.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const o of n.destinations){var u,l;let s;s=null!=(u=o.inscription)&&u.dataB64&&null!=(l=o.inscription)&&l.contentType?(new c).lock(o.address,o.inscription.dataB64,o.inscription.contentType,n.metaData):(new t).lock(o.address),e.addOutput({satoshis:1,lockingScript:s})}for(const o of n.additionalPayments)console.log("Additional payment",o),e.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});for(const o of n.paymentUtxos){const s=p(o,(new t).unlock(n.paymentPk));i.push(`${o.txid}_${o.vout}`),e.addInput(s)}const f=await o.computeFee(e),h=n.paymentUtxos.reduce((t,n)=>t+BigInt(n.satoshis),0n),m=e.outputs.reduce((t,n)=>t+(n.satoshis||0),0);if(h<m)throw new Error("Not enough ordinals to send");if(h>m+f){const o=(new t).lock(n.changeAddress||n.paymentPk.toAddress().toString());a=e.outputs.length,e.addOutput({lockingScript:o,change:!0})}return n.signer&&(e=await g(e,n.signer)),await e.fee(o),await e.sign(),{tx:e,spentOutpoints:i,payChangeVout:a}},w=async n=>{const{utxos:o,paymentPk:e,payments:i,satsPerKb:a=d,changeAddress:c=e.toAddress().toString()}=n,u=new s(a),l=new r;for(const n of i){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};l.addOutput(o)}let f=0n;const g=l.outputs.reduce((t,n)=>t+(n.satoshis||0),0);let h,m=0;for(const n of o){const o=p(n,(new t).unlock(e));if(l.addInput(o),f+=BigInt(n.satoshis),m=await u.computeFee(l),f>=g+m)break}if(f<g+m)throw new Error(`Not enough funds to send. Total sats in: ${f}, Total sats out: ${g}, Fee: ${m}`);if(f>g+m){const n=(new t).lock(c);h=l.outputs.length,l.addOutput({lockingScript:n,change:!0})}else f<g+m&&console.log("No change needed");return await l.fee(u),await l.sign(),{tx:l,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChangeVout:h}};var y;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(y||(y={}));const k=async t=>{const{protocol:n,tokenID:o,utxos:e,inputTokens:s,distributions:r,paymentPk:i,ordPk:a,changeAddress:c,tokenChangeAddress:l,satsPerKb:p=d,metaData:f,signer:g,additionalPayments:h=[]}=t;let w=0n,k=0n,S=0n;if(!s.every(t=>t.id===o))throw new Error("Input tokens do not match the provided tokenID");for(const t of s)k+=BigInt(t.amt);for(const t of r)S+=BigInt(t.amt);if(k<S)throw new Error("Not enough tokens to send");if(w=k-S,w>0n){const t={address:l||a.toAddress().toString(),amt:w.toString()};r.push(t)}const P=r.map(t=>{const e={p:"bsv-20",op:"transfer",amt:t.amt};let s;if(n===y.BSV20)s=u({},e,{tick:o});else{if(n!==y.BSV21)throw new Error("Invalid protocol");s=u({},e,{id:o})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(s)).toString("base64"),contentType:"application/bsv-20"}}}),x={paymentUtxos:e,ordinals:s,paymentPk:i,ordPk:a,destinations:P,changeAddress:c||i.toAddress().toString(),satsPerKb:p,metaData:f,signer:g,additionalPayments:h,enforceUniformSend:!1},{tx:v,spentOutpoints:b,payChangeVout:O}=await m(x);return{tx:v,spentOutpoints:b,payChangeVout:O,tokenChangeVout:P.findIndex(t=>t.address===(l||a.toAddress().toString()))}};export{y as TokenType,h as createOrdinals,f as fetchPayUtxos,m as sendOrdinals,w as sendUtxos,k as transferOrdTokens};
//# sourceMappingURL=index.modern.js.map
