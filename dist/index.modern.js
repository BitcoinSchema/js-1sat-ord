import{P2PKH as t,LockingScript as o,Script as n,Utils as e,fromUtxo as r,SatoshisPerKilobyte as s,Transaction as i}from"@bsv/sdk";import{Sigma as a}from"sigma-protocol";const c=t=>Buffer.from(t).toString("hex"),d=10,u="https://ordinals.gorillapool.io/api";class l extends t{lock(n,e,r,s){let i="";if(void 0!==e&&void 0!==r){const t=c("ord"),o=Buffer.from(e,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=c(r);if(!n)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let a=`${i?`${i} `:""}${(new t).lock(n).toASM()}`;if(s&&(!s.app||!s.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=s&&s.app&&null!=s&&s.type){a=`${a} OP_RETURN ${c("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${c("SET")}`;for(const[t,o]of Object.entries(s))"cmd"!==t&&(a=`${a} ${c(t)} ${c(o)}`)}return o.fromASM(a)}}function f(){return f=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var e in n)({}).hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},f.apply(null,arguments)}var p,h;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(p||(p={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(h||(h={}));const{fromBase58Check:g}=e,m=(t,o)=>{const n=r(f({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o);return n.sourceTXID=t.txid,n},w=async(o,n="base64")=>{const e=`${u}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:e});const r=await fetch(e);if(!r.ok)throw new Error("Error fetching pay utxos");let s=await r.json();s=s.filter(t=>1!==t.satoshis);const i=g(o),a=(new t).lock(i.data);return s=s.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===n||"base64"===n?Buffer.from(a.toBinary()).toString(n):a.toASM()})),s},y=async(t,o,e=10,r=0,s="base64")=>{let i=`${u}/txos/address/${t}/unspent?limit=${e}&offset=${r}&`;o&&(i+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const a=await fetch(i);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const d=c.map(t=>`${t.txid}_${t.vout}`),l=await fetch(`${u}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...d])});if(!l.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await l.json()||[]).map(t=>{let e=t.script;"hex"===s?e=Buffer.from(e,"base64").toString("hex"):"asm"===s&&(e=n.fromHex(Buffer.from(e,"base64").toString("hex")).toASM());const r={origin:t.origin.outpoint,script:e,vout:t.vout,txid:t.txid,satoshis:1};return o&&(r.collectionId=o),r}),c},b=async(t,o,n)=>{const e=`${u}/bsv20/${n}/${t===p.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false`,r=await fetch(e);if(!r.ok)throw new Error(`Error fetching ${t} utxos`);let s=await r.json();return s=s.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),s},x=async(t,o)=>{const n=null==o?void 0:o.idKey,e=null==o?void 0:o.keyHost;if(n){const o=new a(t),{signedTx:e}=o.sign(n);return e}if(e){const n=null==o?void 0:o.authToken,r=new a(t);try{const{signedTx:t}=await r.remoteSign(e,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},k=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[n,e]of Object.entries(t))void 0!==e&&(o[n]="string"==typeof e?e:Array.isArray(e)||"object"==typeof e?JSON.stringify(e):String(e));return o},S=async o=>{const{utxos:n,destinations:e,paymentPk:r,changeAddress:a,satsPerKb:c=d,metaData:u,signer:f,additionalPayments:p=[]}=o,h=new s(c);let g=new i;for(const o of n){const n=m(o,(new t).unlock(r));g.addInput(n)}e.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of e){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(u)for(const t of Object.keys(u))void 0===u[t]&&delete u[t];g.addOutput({satoshis:1,lockingScript:(new l).lock(t.address,t.inscription.dataB64,t.inscription.contentType,k(u))})}for(const o of p)g.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const w=n.reduce((t,o)=>t+BigInt(o.satoshis),0n),y=g.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n),b=await h.computeFee(g);let S;if(w>y+BigInt(b)){const o=(new t).lock(a||r.toAddress().toString()),n={lockingScript:o,change:!0};S={txid:"",vout:g.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},g.addOutput(n)}return f&&(g=await x(g,f)),await g.fee(h),await g.sign(),S&&(S.satoshis=g.outputs[g.outputs.length-1].satoshis,S.txid=g.id("hex")),{tx:g,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:S}},v=async o=>{o.satsPerKb||(o.satsPerKb=d),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const n=new s(o.satsPerKb);let e=new i;const r=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=m(t,(new l).unlock(o.ordPk));r.push(`${t.txid}_${t.vout}`),e.addInput(n)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of o.destinations){var a,c;let r;r=null!=(a=n.inscription)&&a.dataB64&&null!=(c=n.inscription)&&c.contentType?(new l).lock(n.address,n.inscription.dataB64,n.inscription.contentType,k(o.metaData)):(new t).lock(n.address),e.addOutput({satoshis:1,lockingScript:r})}for(const n of o.additionalPayments)e.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});let u=0n;const f=e.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let p,h=0;for(const s of o.paymentUtxos){const i=m(s,(new t).unlock(o.paymentPk));if(r.push(`${s.txid}_${s.vout}`),e.addInput(i),u+=BigInt(s.satoshis),h=await n.computeFee(e),u>=f+BigInt(h))break}if(u<f)throw new Error("Not enough ordinals to send");if(u>f+BigInt(h)){const n=(new t).lock(o.changeAddress||o.paymentPk.toAddress().toString()),r={lockingScript:n,change:!0};p={txid:"",vout:e.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},e.addOutput(r)}return o.signer&&(e=await x(e,o.signer)),await e.fee(n),await e.sign(),p&&(p.satoshis=e.outputs[e.outputs.length-1].satoshis,p.txid=e.id("hex")),{tx:e,spentOutpoints:r,payChange:p}},$=async o=>{const{utxos:n,paymentPk:e,payments:r,satsPerKb:a=d,changeAddress:c=e.toAddress().toString()}=o,u=new s(a),l=new i;for(const o of r){const n={satoshis:o.amount,lockingScript:(new t).lock(o.to)};l.addOutput(n)}let f=0n;const p=l.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let h,g=0;for(const o of n){const n=m(o,(new t).unlock(e));if(l.addInput(n),f+=BigInt(o.satoshis),g=await u.computeFee(l),f>=p+g)break}if(f<p+g)throw new Error(`Not enough funds to send. Total sats in: ${f}, Total sats out: ${p}, Fee: ${g}`);if(f>p+g){const o=(new t).lock(c),n={lockingScript:o,change:!0};h={txid:"",vout:l.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},l.addOutput(n)}else f<p+g&&console.log("No change needed");return await l.fee(u),await l.sign(),h&&(h.satoshis=l.outputs[l.outputs.length-1].satoshis,h.txid=l.id("hex")),{tx:l,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:h}},E=async t=>{const{protocol:o,tokenID:n,utxos:e,inputTokens:r,distributions:s,paymentPk:i,ordPk:a,changeAddress:c,tokenChangeAddress:u,satsPerKb:l=d,metaData:h,signer:g,additionalPayments:m=[]}=t;let w=0n,y=0n,b=0n;if(!r.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of r)y+=BigInt(t.amt);for(const t of s)b+=BigInt(t.amt);if(y<b)throw new Error("Not enough tokens to send");if(w=y-b,w>0n){const t={address:u||a.toAddress().toString(),amt:w.toString()};s.push(t)}const x=s.map(t=>{const e={p:"bsv-20",op:"transfer",amt:t.amt};let r;if(o===p.BSV20)r=f({},e,{tick:n});else{if(o!==p.BSV21)throw new Error("Invalid protocol");r=f({},e,{id:n})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(r)).toString("base64"),contentType:"application/bsv-20"}}}),k={paymentUtxos:e,ordinals:r,paymentPk:i,ordPk:a,destinations:x,changeAddress:c||i.toAddress().toString(),satsPerKb:l,metaData:h,signer:g,additionalPayments:m,enforceUniformSend:!1},{tx:S,spentOutpoints:$,payChange:E}=await v(k),I=x.findIndex(t=>t.address===(u||a.toAddress().toString()));let O;return-1!==I&&(O={id:n,amt:w.toString(),satoshis:1,txid:S.id("hex"),vout:I,script:Buffer.from(S.outputs[I].lockingScript.toHex(),"hex").toString("base64")}),{tx:S,spentOutpoints:$,payChange:E,tokenChange:O}},I=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};export{l as OrdP2PKH,h as RoytaltyType,p as TokenType,S as createOrdinals,y as fetchNftUtxos,w as fetchPayUtxos,b as fetchTokenUtxos,v as sendOrdinals,$ as sendUtxos,k as stringifyMetaData,E as transferOrdTokens,I as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
