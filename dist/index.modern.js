import{P2PKH as t,LockingScript as n,fromUtxo as o,SatoshisPerKilobyte as e,Transaction as s}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const r=t=>Buffer.from(t).toString("hex"),a=10;class d extends t{lock(o,e,s,i){let a="";if(void 0!==e&&void 0!==s){const t=r("ord"),n=Buffer.from(e,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=r(s);if(!o)throw new Error("Invalid media type");a=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let d=`${a?`${a} `:""}${(new t).lock(o).toASM()}`;if(i&&(!i.app||!i.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=i&&i.app&&null!=i&&i.type){d=`${d} OP_RETURN ${r("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${r("SET")}`;for(const[t,n]of Object.entries(i))"cmd"!==t&&(d=`${d} ${r(t)} ${r(n)}`)}return n.fromASM(d)}}function c(){return c=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var e in o)({}).hasOwnProperty.call(o,e)&&(t[e]=o[e])}return t},c.apply(null,arguments)}const u=(t,n)=>{const e=o(c({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return e.sourceTXID=t.txid,e},p=async(t,n)=>{const o=null==n?void 0:n.idKey,e=null==n?void 0:n.keyHost;if(o){const n=new i(t),{signedTx:e}=n.sign(o);return e}if(e){const o=null==n?void 0:n.authToken,s=new i(t);try{const{signedTx:t}=await s.remoteSign(e,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},l=async n=>{const{utxos:o,destinations:i,paymentPk:r,changeAddress:c,satsPerKb:l=a,metaData:f,signer:g,additionalPayments:h=[]}=n,m=new e(l);let w,k=new s;for(const n of o){const o=u(n,(new t).unlock(r));k.addInput(o)}i.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of i){if(!t.inscription)throw new Error("Inscription is required for all destinations");k.addOutput({satoshis:1,lockingScript:(new d).lock(t.address,t.inscription.dataB64,t.inscription.contentType,f)})}for(const n of h)k.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});const y=o.reduce((t,n)=>t+BigInt(n.satoshis),0n),S=k.outputs.reduce((t,n)=>t+BigInt(n.satoshis||0),0n),P=await m.computeFee(k);return y>S+BigInt(P)&&(k.addOutput({lockingScript:(new t).lock(c||r.toAddress().toString()),change:!0}),w=k.outputs.length-1),g&&(k=await p(k,g)),await k.fee(m),await k.sign(),{tx:k,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChangeVout:w}},f=async n=>{n.satsPerKb||(n.satsPerKb=a),n.additionalPayments||(n.additionalPayments=[]),void 0===n.enforceUniformSend&&(n.enforceUniformSend=!0);const o=new e(n.satsPerKb);let i=new s;const r=[];let c;for(const t of n.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const o=u(t,(new d).unlock(n.ordPk));r.push(`${t.txid}_${t.vout}`),i.addInput(o)}if(n.enforceUniformSend&&n.destinations.length!==n.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const o of n.destinations){var l,f;let e;e=null!=(l=o.inscription)&&l.dataB64&&null!=(f=o.inscription)&&f.contentType?(new d).lock(o.address,o.inscription.dataB64,o.inscription.contentType,n.metaData):(new t).lock(o.address),i.addOutput({satoshis:1,lockingScript:e})}for(const o of n.additionalPayments)console.log("Additional payment",o),i.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});for(const o of n.paymentUtxos){const e=u(o,(new t).unlock(n.paymentPk));r.push(`${o.txid}_${o.vout}`),i.addInput(e)}const g=await o.computeFee(i),h=n.paymentUtxos.reduce((t,n)=>t+BigInt(n.satoshis),0n),m=i.outputs.reduce((t,n)=>t+(n.satoshis||0),0);if(h<m)throw new Error("Not enough ordinals to send");if(h>m+g){const o=(new t).lock(n.changeAddress||n.paymentPk.toAddress().toString());c=i.outputs.length,i.addOutput({lockingScript:o,change:!0})}return n.signer&&(i=await p(i,n.signer)),await i.fee(o),await i.sign(),{tx:i,spentOutpoints:r,payChangeVout:c}},g=async n=>{const{utxos:o,paymentPk:i,payments:r,satsPerKb:d=a,changeAddress:c=i.toAddress().toString()}=n,p=new e(d),l=new s;for(const n of r){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};l.addOutput(o)}let f=0n;const g=l.outputs.reduce((t,n)=>t+(n.satoshis||0),0);let h,m=0;for(const n of o){const o=u(n,(new t).unlock(i));if(l.addInput(o),f+=BigInt(n.satoshis),m=await p.computeFee(l),f>=g+m)break}if(f<g+m)throw new Error(`Not enough funds to send. Total sats in: ${f}, Total sats out: ${g}, Fee: ${m}`);if(f>g+m){const n=(new t).lock(c);h=l.outputs.length,l.addOutput({lockingScript:n,change:!0})}else f<g+m&&console.log("No change needed");return await l.fee(p),await l.sign(),{tx:l,spentOutpoints:o.map(t=>`${t.txid}_${t.vout}`),payChangeVout:h}};var h;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(h||(h={}));const m=async t=>{const{protocol:n,tokenID:o,utxos:e,inputTokens:s,distributions:i,paymentPk:r,ordPk:d,changeAddress:u,tokenChangeAddress:p,satsPerKb:l=a,metaData:g,signer:m,additionalPayments:w=[]}=t;let k=0n,y=0n,S=0n;if(!s.every(t=>t.id===o))throw new Error("Input tokens do not match the provided tokenID");for(const t of s)y+=BigInt(t.amt);for(const t of i)S+=BigInt(t.amt);if(y<S)throw new Error("Not enough tokens to send");if(k=y-S,k>0n){const t={address:p||d.toAddress().toString(),amt:k.toString()};i.push(t)}const P=i.map(t=>{const e={p:"bsv-20",op:"transfer",amt:t.amt};let s;if(n===h.BSV20)s=c({},e,{tick:o});else{if(n!==h.BSV21)throw new Error("Invalid protocol");s=c({},e,{id:o})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(s)).toString("base64"),contentType:"application/bsv-20"}}}),b={paymentUtxos:e,ordinals:s,paymentPk:r,ordPk:d,destinations:P,changeAddress:u||r.toAddress().toString(),satsPerKb:l,metaData:g,signer:m,additionalPayments:w,enforceUniformSend:!1},{tx:v,spentOutpoints:x,payChangeVout:O}=await f(b);return{tx:v,spentOutpoints:x,payChangeVout:O,tokenChangeVout:P.findIndex(t=>t.address===(p||d.toAddress().toString()))}};export{l as createOrdinals,f as sendOrdinals,g as sendUtxos,m as transferOrdTokens};
//# sourceMappingURL=index.modern.js.map
