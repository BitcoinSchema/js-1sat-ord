import{P2PKH as t,LockingScript as o,Utils as n,fromUtxo as e,SatoshisPerKilobyte as r,Transaction as s}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const a=t=>Buffer.from(t).toString("hex"),c=10,d="https://ordinals.gorillapool.io/api";class u extends t{lock(n,e,r,s){let i="";if(void 0!==e&&void 0!==r){const t=a("ord"),o=Buffer.from(e,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=a(r);if(!n)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let c=`${i?`${i} `:""}${(new t).lock(n).toASM()}`;if(s&&(!s.app||!s.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=s&&s.app&&null!=s&&s.type){c=`${c} OP_RETURN ${a("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${a("SET")}`;for(const[t,o]of Object.entries(s))"cmd"!==t&&(c=`${c} ${a(t)} ${a(o)}`)}return o.fromASM(c)}}function l(){return l=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var e in n)({}).hasOwnProperty.call(n,e)&&(t[e]=n[e])}return t},l.apply(null,arguments)}var f,p;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(f||(f={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(p||(p={}));const{fromBase58Check:h}=n,g=(t,o)=>{const n=e(l({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o);return n.sourceTXID=t.txid,n},m=async(o,n="base64")=>{const e=`${d}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:e});const r=await fetch(e);if(!r.ok)throw new Error("Error fetching pay utxos");let s=await r.json();s=s.filter(t=>1!==t.satoshis);const i=h(o),a=(new t).lock(i.data);return s=s.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===n||"base64"===n?Buffer.from(a.toBinary()).toString(n):a.toASM()})),s},w=async(t,o,n=10,e=0)=>{let r=`${d}/txos/address/${t}/unspent?limit=${n}&offset=${e}&`;o&&(r+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const s=await fetch(r);if(!s.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let i=await s.json();i=i.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const a=i.map(t=>`${t.txid}_${t.vout}`),c=await fetch(`${d}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...a])});if(!c.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return i=(await c.json()||[]).map(t=>{const n={origin:t.origin.outpoint,script:t.script,vout:t.vout,txid:t.txid,satoshis:1};return o&&(n.collectionId=o),n}),i},y=async(t,o,n)=>{const e=`${d}/bsv20/${n}/${t===f.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false`,r=await fetch(e);if(!r.ok)throw new Error(`Error fetching ${t} utxos`);let s=await r.json();return s=s.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),s},b=async(t,o)=>{const n=null==o?void 0:o.idKey,e=null==o?void 0:o.keyHost;if(n){const o=new i(t),{signedTx:e}=o.sign(n);return e}if(e){const n=null==o?void 0:o.authToken,r=new i(t);try{const{signedTx:t}=await r.remoteSign(e,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},k=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[n,e]of Object.entries(t))void 0!==e&&(o[n]="string"==typeof e?e:Array.isArray(e)||"object"==typeof e?JSON.stringify(e):String(e));return o},x=async o=>{const{utxos:n,destinations:e,paymentPk:i,changeAddress:a,satsPerKb:d=c,metaData:l,signer:f,additionalPayments:p=[]}=o,h=new r(d);let m=new s;for(const o of n){const n=g(o,(new t).unlock(i));m.addInput(n)}e.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of e){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(l)for(const t of Object.keys(l))void 0===l[t]&&delete l[t];m.addOutput({satoshis:1,lockingScript:(new u).lock(t.address,t.inscription.dataB64,t.inscription.contentType,k(l))})}for(const o of p)m.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const w=n.reduce((t,o)=>t+BigInt(o.satoshis),0n),y=m.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n),x=await h.computeFee(m);let v;if(w>y+BigInt(x)){const o=(new t).lock(a||i.toAddress().toString()),n={lockingScript:o,change:!0};v={txid:"",vout:m.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},m.addOutput(n)}return f&&(m=await b(m,f)),await m.fee(h),await m.sign(),v&&(v.satoshis=m.outputs[m.outputs.length-1].satoshis,v.txid=m.id("hex")),{tx:m,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:v}},v=async o=>{o.satsPerKb||(o.satsPerKb=c),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const n=new r(o.satsPerKb);let e=new s;const i=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=g(t,(new u).unlock(o.ordPk));i.push(`${t.txid}_${t.vout}`),e.addInput(n)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of o.destinations){var a,d;let r;r=null!=(a=n.inscription)&&a.dataB64&&null!=(d=n.inscription)&&d.contentType?(new u).lock(n.address,n.inscription.dataB64,n.inscription.contentType,k(o.metaData)):(new t).lock(n.address),e.addOutput({satoshis:1,lockingScript:r})}for(const n of o.additionalPayments)e.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});let l=0n;const f=e.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let p,h=0;for(const r of o.paymentUtxos){const s=g(r,(new t).unlock(o.paymentPk));if(i.push(`${r.txid}_${r.vout}`),e.addInput(s),l+=BigInt(r.satoshis),h=await n.computeFee(e),l>=f+BigInt(h))break}if(l<f)throw new Error("Not enough ordinals to send");if(l>f+BigInt(h)){const n=(new t).lock(o.changeAddress||o.paymentPk.toAddress().toString()),r={lockingScript:n,change:!0};p={txid:"",vout:e.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},e.addOutput(r)}return o.signer&&(e=await b(e,o.signer)),await e.fee(n),await e.sign(),p&&(p.satoshis=e.outputs[e.outputs.length-1].satoshis,p.txid=e.id("hex")),{tx:e,spentOutpoints:i,payChange:p}},S=async o=>{const{utxos:n,paymentPk:e,payments:i,satsPerKb:a=c,changeAddress:d=e.toAddress().toString()}=o,u=new r(a),l=new s;for(const o of i){const n={satoshis:o.amount,lockingScript:(new t).lock(o.to)};l.addOutput(n)}let f=0n;const p=l.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let h,m=0;for(const o of n){const n=g(o,(new t).unlock(e));if(l.addInput(n),f+=BigInt(o.satoshis),m=await u.computeFee(l),f>=p+m)break}if(f<p+m)throw new Error(`Not enough funds to send. Total sats in: ${f}, Total sats out: ${p}, Fee: ${m}`);if(f>p+m){const o=(new t).lock(d),n={lockingScript:o,change:!0};h={txid:"",vout:l.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},l.addOutput(n)}else f<p+m&&console.log("No change needed");return await l.fee(u),await l.sign(),h&&(h.satoshis=l.outputs[l.outputs.length-1].satoshis,h.txid=l.id("hex")),{tx:l,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:h}},$=async t=>{const{protocol:o,tokenID:n,utxos:e,inputTokens:r,distributions:s,paymentPk:i,ordPk:a,changeAddress:d,tokenChangeAddress:u,satsPerKb:p=c,metaData:h,signer:g,additionalPayments:m=[]}=t;let w=0n,y=0n,b=0n;if(!r.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of r)y+=BigInt(t.amt);for(const t of s)b+=BigInt(t.amt);if(y<b)throw new Error("Not enough tokens to send");if(w=y-b,w>0n){const t={address:u||a.toAddress().toString(),amt:w.toString()};s.push(t)}const k=s.map(t=>{const e={p:"bsv-20",op:"transfer",amt:t.amt};let r;if(o===f.BSV20)r=l({},e,{tick:n});else{if(o!==f.BSV21)throw new Error("Invalid protocol");r=l({},e,{id:n})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(r)).toString("base64"),contentType:"application/bsv-20"}}}),x={paymentUtxos:e,ordinals:r,paymentPk:i,ordPk:a,destinations:k,changeAddress:d||i.toAddress().toString(),satsPerKb:p,metaData:h,signer:g,additionalPayments:m,enforceUniformSend:!1},{tx:S,spentOutpoints:$,payChange:E}=await v(x),I=k.findIndex(t=>t.address===(u||a.toAddress().toString()));let O;return-1!==I&&(O={id:n,amt:w.toString(),satoshis:1,txid:S.id("hex"),vout:I,script:Buffer.from(S.outputs[I].lockingScript.toHex(),"hex").toString("base64")}),{tx:S,spentOutpoints:$,payChange:E,tokenChange:O}},E=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};export{u as OrdP2PKH,p as RoytaltyType,f as TokenType,x as createOrdinals,w as fetchNftUtxos,m as fetchPayUtxos,y as fetchTokenUtxos,v as sendOrdinals,S as sendUtxos,k as stringifyMetaData,$ as transferOrdTokens,E as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
