import{Script as t,Transaction as n,TxIn as s,P2PKHAddress as o,TxOut as e,SigHash as i}from"bsv-wasm";import{Buffer as r}from"buffer";import*as _ from"dotenv";import{Sigma as g}from"sigma-protocol";const c=t=>{for(var n=[],s=0,o=t.length;s<o;s++){var e=Number(t.charCodeAt(s)).toString(16);n.push(e)}return n.join("")};_.config();const a=(n,s,o,e)=>{const i=c("ord"),_=r.from(s,"base64").toString("hex"),g=c(o);let a=`${n.get_locking_script().to_asm_string()} OP_0 OP_IF ${i} OP_1 ${g} OP_0 ${_} OP_ENDIF`;if(e&&null!=e&&e.app&&null!=e&&e.type){a=`${a} OP_RETURN ${c("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${c("SET")}`;for(const[t,n]of Object.entries(e))"cmd"!==t&&(a=`${a} ${c(t)} ${c(n)}`)}return t.from_asm_string(a)},u=async(_,c,u,l,m,p,f,d)=>{let h=new n(1,0),w=new s(r.from(_.txid,"hex"),_.vout,t.from_asm_string(""));h.add_input(w);const x=a(o.from_string(c),p.dataB64,p.contentType,f);let I=new e(BigInt(1),x);h.add_output(I);const y=o.from_string(l).get_locking_script();let $=new e(BigInt(1),y);const k=Math.ceil(m*(h.get_size()+$.to_bytes().byteLength)),B=_.satoshis-1-k;if(B<0)throw new Error("Inadequate satoshis for fee");if(B>0){let t=new e(BigInt(B),y);h.add_output(t)}const b=null==d?void 0:d.idKey,O=null==d?void 0:d.keyHost;if(b){const t=new g(h),{signedTx:n}=t.sign(b);h=n}else if(O){const t=null==d?void 0:d.authToken,n=new g(h);try{const{signedTx:s}=await n.remoteSign(O,t);h=s}catch(t){throw console.log(t),new Error("Remote signing to "+O+" failed")}}const v=h.sign(u,i.ALL|i.FORKID,0,t.from_asm_string(_.script),BigInt(_.satoshis));return w.set_unlocking_script(t.from_asm_string(`${v.to_hex()} ${u.to_public_key().to_hex()}`)),h.set_input(0,w),h},l=async(_,g,c,u,l,m,p,f,d)=>{let h=new n(1,0),w=new s(r.from(g.txid,"hex"),g.vout,t.from_asm_string(""));h.add_input(w);let x,I=new s(r.from(_.txid,"hex"),_.vout,t.from_asm_string(""));h.add_input(I);const y=o.from_string(p);x=null!=f&&f.dataB64&&null!=f&&f.contentType?a(y,f.dataB64,f.contentType,d):y.get_locking_script();let $=new e(BigInt(1),x);h.add_output($);const k=o.from_string(u).get_locking_script();let B=new e(BigInt(1),k);const b=Math.ceil(l*(h.get_size()+B.to_bytes().byteLength));let O=new e(BigInt(_.satoshis-b),k);h.add_output(O);const v=h.sign(m,i.InputOutput,0,t.from_asm_string(g.script),BigInt(g.satoshis));w.set_unlocking_script(t.from_asm_string(`${v.to_hex()} ${m.to_public_key().to_hex()}`)),h.set_input(0,w);const T=h.sign(c,i.InputOutput,1,t.from_asm_string(_.script),BigInt(_.satoshis));return I.set_unlocking_script(t.from_asm_string(`${T.to_hex()} ${c.to_public_key().to_hex()}`)),h.set_input(1,I),h},m=async(o,_,g,c)=>{const a=new n(1,0);let u=0;for(let t of o||[])u+=t.satoshis;const l=u-c;console.log({feeSats:c,satsIn:u,satsOut:l}),a.add_output(new e(BigInt(l),g.get_locking_script()));let m=0;for(let n of o||[]){console.log({u:n});const o=new s(r.from(n.txid,"hex"),n.vout,t.from_asm_string(""));console.log({inx:o}),o.set_satoshis(BigInt(n.satoshis)),a.add_input(o);const e=a.sign(_,i.InputOutputs,m,t.from_asm_string(n.script),BigInt(n.satoshis));o.set_unlocking_script(t.from_asm_string(`${e.to_hex()} ${_.to_public_key().to_hex()}`)),a.set_input(m,o),m++}return a};export{a as buildInscription,u as createOrdinal,l as sendOrdinal,m as sendUtxos};
//# sourceMappingURL=index.modern.js.map
