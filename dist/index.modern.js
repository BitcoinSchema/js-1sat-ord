import{P2PKH as t,LockingScript as n,fromUtxo as o,SatoshisPerKilobyte as r,Transaction as e}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const s=t=>Buffer.from(t).toString("hex");class a extends t{lock(o,r,e,i){let a="";if(void 0!==r&&void 0!==e){const t=s("ord"),n=Buffer.from(r,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=s(e);if(!o)throw new Error("Invalid media type");a=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let c=`${a?`${a} `:""}${(new t).lock(o).toASM()}`;if(i&&(!i.app||!i.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=i&&i.app&&null!=i&&i.type){c=`${c} OP_RETURN ${s("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${s("SET")}`;for(const[t,n]of Object.entries(i))"cmd"!==t&&(c=`${c} ${s(t)} ${s(n)}`)}return n.fromASM(c)}}function c(){return c=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var r in o)({}).hasOwnProperty.call(o,r)&&(t[r]=o[r])}return t},c.apply(null,arguments)}const l=(t,n)=>{const r=o(c({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return r.sourceTXID=t.txid,r},d=async(t,n)=>{const o=null==n?void 0:n.idKey,r=null==n?void 0:n.keyHost;if(o){const n=new i(t),{signedTx:r}=n.sign(o);return r}if(r){const o=null==n?void 0:n.authToken,e=new i(t);try{const{signedTx:t}=await e.remoteSign(r,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${r} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},u=async(n,o,i,s,c=10,u,f,p=[])=>{const w=new r(c);let g=new e;for(const o of n){const n=l(o,(new t).unlock(i));g.addInput(n)}o.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of o){if(!t.inscription)throw new Error("Inscription is required for all destinations");g.addOutput({satoshis:1,lockingScript:(new a).lock(t.address,t.inscription.dataB64,t.inscription.contentType,u)})}for(const n of p)g.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});return g.addOutput({lockingScript:(new t).lock(s||i.toAddress().toString()),change:!0}),f&&(g=await d(g,f)),await g.fee(w),await g.sign(),g},f=async(n,o,i,s,c,u,f=10,p,w,g=[],h=!0)=>{const k=new r(f);let m=new e;for(const t of o){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=l(t,(new a).unlock(s));m.addInput(n)}for(const o of n){const n=l(o,(new t).unlock(i));m.addInput(n)}if(h&&c.length!==o.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of c){var S,y;let o;o=null!=(S=n.inscription)&&S.dataB64&&null!=(y=n.inscription)&&y.contentType?(new a).lock(n.address,n.inscription.dataB64,n.inscription.contentType,p):(new t).lock(n.address),m.addOutput({satoshis:1,lockingScript:o})}for(const n of g)console.log("Additional payment",n),m.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});const O=(new t).lock(u||i.toAddress().toString());return m.addOutput({lockingScript:O,change:!0}),w&&(m=await d(m,w)),await m.fee(k),await m.sign(),m},p=async(n,o,i,s=10)=>{const a=new r(s),c=new e;for(const r of n){const n=l(r,(new t).unlock(o));c.addInput(n)}for(const n of i){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};c.addOutput(o)}const d=o.toAddress().toString(),u=(new t).lock(d);return c.addOutput({lockingScript:u,change:!0}),await c.fee(a),await c.sign(),c};export{u as createOrdinals,f as sendOrdinals,p as sendUtxos};
//# sourceMappingURL=index.modern.js.map
