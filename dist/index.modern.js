import{P2PKH as t,LockingScript as o,Script as e,Utils as s,fromUtxo as n,SatoshisPerKilobyte as i,Transaction as r,OP as a,BigNumber as c,UnlockingScript as u,TransactionSignature as f}from"@bsv/sdk";import{Sigma as d}from"sigma-protocol";const l=t=>Buffer.from(t).toString("hex"),p=10,h="https://ordinals.gorillapool.io/api";class g extends t{lock(e,s,n){let i="";if(void 0!==(null==s?void 0:s.dataB64)&&void 0!==(null==s?void 0:s.contentType)){const t=l("ord"),o=Buffer.from(s.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const e=l(s.contentType);if(!e)throw new Error("Invalid media type");i=`OP_0 OP_IF ${t} OP_1 ${e} OP_0 ${o} OP_ENDIF`}let r=`${i?`${i} `:""}${(new t).lock(e).toASM()}`;if(n&&(!n.app||!n.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=n&&n.app&&null!=n&&n.type){r=`${r} OP_RETURN ${l("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${l("SET")}`;for(const[t,o]of Object.entries(n))"cmd"!==t&&(r=`${r} ${l(t)} ${l(o)}`)}return o.fromASM(r)}}function w(){return w=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var e=arguments[o];for(var s in e)({}).hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},w.apply(null,arguments)}var m,y;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(m||(m={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(y||(y={}));const{fromBase58Check:b}=s,k=(t,o)=>n(w({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o),x=async(o,e="base64")=>{const s=`${h}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:s});const n=await fetch(s);if(!n.ok)throw new Error("Error fetching pay utxos");let i=await n.json();i=i.filter(t=>1!==t.satoshis);const r=b(o),a=(new t).lock(r.data);return i=i.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===e||"base64"===e?Buffer.from(a.toBinary()).toString(e):a.toASM()})),i},S=async(t,o,s=10,n=0,i="base64")=>{let r=`${h}/txos/address/${t}/unspent?limit=${s}&offset=${n}&`;o&&(r+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const a=await fetch(r);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const u=c.map(t=>`${t.txid}_${t.vout}`),f=await fetch(`${h}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...u])});if(!f.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await f.json()||[]).map(t=>{let s=t.script;"hex"===i?s=Buffer.from(s,"base64").toString("hex"):"asm"===i&&(s=e.fromHex(Buffer.from(s,"base64").toString("hex")).toASM());const n={origin:t.origin.outpoint,script:s,vout:t.vout,txid:t.txid,satoshis:1};return o&&(n.collectionId=o),n}),c},B=async(t,o,e)=>{const s=`${h}/bsv20/${e}/${t===m.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false`,n=await fetch(s);if(!n.ok)throw new Error(`Error fetching ${t} utxos`);let i=await n.json();return i=i.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),i},I=async(t,o)=>{const e=null==o?void 0:o.idKey,s=null==o?void 0:o.keyHost;if(e){const o=new d(t),{signedTx:s}=o.sign(e);return s}if(s){const e=null==o?void 0:o.authToken,n=new d(t);try{const{signedTx:t}=await n.remoteSign(s,e);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${s} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},v=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[e,s]of Object.entries(t))void 0!==s&&(o[e]="string"==typeof s?s:Array.isArray(s)||"object"==typeof s?JSON.stringify(s):String(s));return o},O=async o=>{const{utxos:n,destinations:a,paymentPk:c,changeAddress:u,satsPerKb:f=p,metaData:d,signer:l,additionalPayments:h=[]}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const w=new i(f);let m,y=new r;for(const t of a){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(d)for(const t of Object.keys(d))void 0===d[t]&&delete d[t];y.addOutput({satoshis:1,lockingScript:(new g).lock(t.address,t.inscription,v(d))})}for(const o of h)y.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const b=u||c.toAddress().toString(),x=(new t).lock(b);y.addOutput({lockingScript:x,change:!0});let S=0n;const B=y.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);if(l){const o=n.pop();y.addInput(k(o,(new t).unlock(c,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))))),S+=BigInt(o.satoshis),y=await I(y,l)}let O=0;for(const o of n){if(S>=B+BigInt(O))break;const n=k(o,(new t).unlock(c,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));y.addInput(n),S+=BigInt(o.satoshis),O=await w.computeFee(y)}if(S<B+BigInt(O))throw new Error(`Not enough funds to purchase listing. Total sats in: ${S}, Total sats out: ${B}, Fee: ${O}`);await y.fee(w),await y.sign();const $=y.outputs.findIndex(t=>t.change);if(-1!==$){const t=y.outputs[$];m={satoshis:t.satoshis,txid:y.id("hex"),vout:$,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=y.outputs[y.outputs.length-1].satoshis,m.txid=y.id("hex")),{tx:y,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:m}},$=async o=>{o.satsPerKb||(o.satsPerKb=p),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const n=new i(o.satsPerKb);let a=new r;const c=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=k(t,(new g).unlock(o.ordPk,"all",!0,t.satoshis,e.fromBinary(s.toArray(t.script,"base64"))));c.push(`${t.txid}_${t.vout}`),a.addInput(n)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const e of o.destinations){var u,f;let s;s=null!=(u=e.inscription)&&u.dataB64&&null!=(f=e.inscription)&&f.contentType?(new g).lock(e.address,e.inscription,v(o.metaData)):(new t).lock(e.address),a.addOutput({satoshis:1,lockingScript:s})}for(const e of o.additionalPayments)a.addOutput({satoshis:e.amount,lockingScript:(new t).lock(e.to)});let d=0n;const l=a.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let h,w=0;for(const i of o.paymentUtxos){const r=k(i,(new t).unlock(o.paymentPk,"all",!0,i.satoshis,e.fromBinary(s.toArray(i.script,"base64"))));if(c.push(`${i.txid}_${i.vout}`),a.addInput(r),d+=BigInt(i.satoshis),w=await n.computeFee(a),d>=l+BigInt(w))break}if(d<l)throw new Error("Not enough ordinals to send");if(d>l+BigInt(w)){const e=(new t).lock(o.changeAddress||o.paymentPk.toAddress().toString()),s={lockingScript:e,change:!0};h={txid:"",vout:a.outputs.length,satoshis:0,script:Buffer.from(e.toHex(),"hex").toString("base64")},a.addOutput(s)}o.signer&&(a=await I(a,o.signer)),await a.fee(n),await a.sign();const m=a.outputs.findIndex(t=>t.change);if(-1!==m){const t=a.outputs[m];h={satoshis:t.satoshis,txid:a.id("hex"),vout:m,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return h&&(h.satoshis=a.outputs[a.outputs.length-1].satoshis,h.txid=a.id("hex")),{tx:a,spentOutpoints:c,payChange:h}},A=async o=>{const{utxos:n,paymentPk:a,payments:c,satsPerKb:u=p,changeAddress:f=a.toAddress().toString()}=o,d=new i(u),l=new r;for(const o of c){const e={satoshis:o.amount,lockingScript:(new t).lock(o.to)};l.addOutput(e)}let h=0n;const g=l.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let w,m=0;for(const o of n){const n=k(o,(new t).unlock(a,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));if(l.addInput(n),h+=BigInt(o.satoshis),m=await d.computeFee(l),h>=g+m)break}if(h<g+m)throw new Error(`Not enough funds to send. Total sats in: ${h}, Total sats out: ${g}, Fee: ${m}`);if(h>g+m){const o=(new t).lock(f),e={lockingScript:o,change:!0};w={txid:"",vout:l.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},l.addOutput(e)}else h<g+m&&console.log("No change needed");await l.fee(d),await l.sign();const y=l.outputs.findIndex(t=>t.change);if(-1!==y){const t=l.outputs[y];w={satoshis:t.satoshis,txid:l.id("hex"),vout:y,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return w&&(w.satoshis=l.outputs[l.outputs.length-1].satoshis,w.txid=l.id("hex")),{tx:l,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:w}},E=async o=>{const{protocol:n,tokenID:a,utxos:c,inputTokens:u,distributions:f,paymentPk:d,ordPk:l,changeAddress:h,tokenChangeAddress:y,satsPerKb:b=p,additionalPayments:x=[],burn:S=!1}=o;let B=0n,I=0n,v=0n;if(!u.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");const O=new i(b),$=new r;for(const t of u){const o=s.toArray(t.script,"base64"),n=e.fromBinary(o);$.addInput(k(t,(new g).unlock(l,"all",!0,t.satoshis,n))),I+=BigInt(t.amt)}for(const t of f){const o={p:"bsv-20",op:S?"burn":"transfer",amt:t.amt};let e;if(n===m.BSV20)e=w({},o,{tick:a});else{if(n!==m.BSV21)throw new Error("Invalid protocol");e=w({},o,{id:a})}$.addOutput({satoshis:1,lockingScript:(new g).lock(t.address,{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv20"})}),v+=BigInt(t.amt)}let A,E;if(B=I-v,B<0n)throw new Error("Not enough tokens to send");if(B>0n){const t={p:"bsv-20",op:"transfer",amt:B.toString()};let o;if(n===m.BSV20)o=w({},t,{tick:a});else{if(n!==m.BSV21)throw new Error("Invalid protocol");o=w({},t,{id:a})}const e=(new g).lock(y||l.toAddress().toString(),{dataB64:Buffer.from(JSON.stringify(o)).toString("base64"),contentType:"application/bsv-20"}),s=$.outputs.length;$.addOutput({lockingScript:e,satoshis:1}),A={id:a,satoshis:1,script:Buffer.from(e.toBinary()).toString("base64"),txid:"",vout:s,amt:B.toString()}}for(const o of x)$.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const P=h||d.toAddress().toString(),T=(new t).lock(P);$.addOutput({lockingScript:T,change:!0});let C=0n;const N=$.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let _=0;for(const o of c){const n=k(o,(new t).unlock(d,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));if($.addInput(n),C+=BigInt(o.satoshis),_=await O.computeFee($),C>=N+BigInt(_))break}if(C<N+BigInt(_))throw new Error(`Not enough funds to purchase listing. Total sats in: ${C}, Total sats out: ${N}, Fee: ${_}`);await $.fee(O),await $.sign();const F=$.id("hex");A&&(A.txid=F);const j=$.outputs.findIndex(t=>t.change);if(-1!==j){const t=$.outputs[j];E={satoshis:t.satoshis,txid:F,vout:j,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return E&&(E.satoshis=$.outputs[$.outputs.length-1].satoshis,E.txid=$.id("hex")),{tx:$,spentOutpoints:$.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:E,tokenChange:A}},P=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};class T{lock(o,n,i,r){const a=s.fromBase58Check(o).data,c=s.fromBase58Check(n).data;let u=new e;if(void 0!==(null==r?void 0:r.dataB64)&&void 0!==(null==r?void 0:r.contentType)){const t=l("ord"),o=Buffer.from(r.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const s=l(r.contentType);if(!s)throw new Error("Invalid media type");u=e.fromASM(`OP_0 OP_IF ${t} OP_1 ${s} OP_0 ${o} OP_ENDIF`)}return u.writeScript(e.fromHex("2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000")).writeBin(a).writeBin(T.buildOutput(i,(new t).lock(c).toBinary())).writeScript(e.fromHex("615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868"))}cancelListing(o,e="all",s=!1,n,i){const r=(new t).unlock(o,e,s,n,i);return{sign:async function(t,o){return(await r.sign(t,o)).writeOpCode(a.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,o){const e={sign:async function(e,n){var i;if(e.outputs.length<2)throw new Error("Malformed transaction");const r=(new u).writeBin(T.buildOutput(e.outputs[0].satoshis||0,e.outputs[0].lockingScript.toBinary()));if(e.outputs.length>2){const t=new s.Writer;for(const o of e.outputs.slice(2))t.write(T.buildOutput(o.satoshis||0,o.lockingScript.toBinary()));r.writeBin(t.toArray())}else r.writeOpCode(a.OP_0);const c=e.inputs[n];let d;if(!t&&c.sourceTransaction)d=c.sourceTransaction.outputs[c.sourceOutputIndex].satoshis;else if(!t)throw new Error("sourceTransaction or sourceSatoshis is required");d=t;const l=c.sourceTXID||(null==(i=c.sourceTransaction)?void 0:i.id("hex"));let p=o;var h;o||(p=null==(h=c.sourceTransaction)?void 0:h.outputs[c.sourceOutputIndex].lockingScript);const g=f.format({sourceTXID:l,sourceOutputIndex:c.sourceOutputIndex,sourceSatoshis:d,transactionVersion:e.version,otherInputs:[],inputIndex:n,outputs:e.outputs,inputSequence:c.sequence,subscript:p,lockTime:e.lockTime,scope:f.SIGHASH_ALL|f.SIGHASH_ANYONECANPAY|f.SIGHASH_FORKID});return r.writeBin(g).writeOpCode(a.OP_0)},estimateLength:async function(t,o){return(await e.sign(t,o)).toBinary().length}};return e}static buildOutput(t,o){const e=new s.Writer;return e.writeUInt64LEBn(new c(t)),e.writeVarIntNum(o.length),e.write(o),e.toArray()}}const{toArray:C}=s,N=async o=>{const{utxos:n,listings:a,paymentPk:c,ordPk:u,changeAddress:f,satsPerKb:d=p,additionalPayments:l=[]}=o,h=new i(d),w=new r;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of a){w.addOutput({satoshis:1,lockingScript:(new T).lock(t.payAddress,t.ordAddress,t.price)});const o=C(t.listingUtxo.script,"base64"),s=e.fromBinary(o);w.addInput(k(t.listingUtxo,(new g).unlock(u,"all",!0,t.listingUtxo.satoshis,s)))}for(const o of l)w.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let m;const y=(new t).lock(f||c.toAddress().toString());w.addOutput({lockingScript:y,change:!0});let b=0n;const x=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let S=0;for(const o of n){const n=k(o,(new t).unlock(c,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));if(w.addInput(n),b+=BigInt(o.satoshis),S=await h.computeFee(w),b>=x+BigInt(S))break}if(b<x+BigInt(S))throw new Error(`Not enough funds to purchase listing. Total sats in: ${b}, Total sats out: ${x}, Fee: ${S}`);await w.fee(h),await w.sign();const B=w.outputs.findIndex(t=>t.change);if(-1!==B){const t=w.outputs[B];m={satoshis:t.satoshis,txid:w.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=w.outputs[w.outputs.length-1].satoshis,m.txid=w.id("hex")),{tx:w,spentOutpoints:w.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:m}},_=async o=>{const{utxos:n,listingUtxos:a,ordPk:c,paymentPk:u,changeAddress:f,additionalPayments:d,satsPerKb:l=p}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const h=new i(l),g=new r;for(const o of a)g.addInput(k(o,(new T).cancelListing(c,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))))),g.addOutput({satoshis:1,lockingScript:(new t).lock(c.toAddress().toString())});for(const o of d)g.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let w;const m=f||u.toAddress().toString(),y=(new t).lock(m);g.addOutput({lockingScript:y,change:!0});let b=0n;const x=g.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let S=0;for(const o of n){const n=k(o,(new t).unlock(u,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));if(g.addInput(n),b+=BigInt(o.satoshis),S=await h.computeFee(g),b>=x+BigInt(S))break}if(b<x+BigInt(S))throw new Error(`Not enough funds to purchase listing. Total sats in: ${b}, Total sats out: ${x}, Fee: ${S}`);await g.fee(h),await g.sign();const B=g.outputs.findIndex(t=>t.change);if(-1!==B){const t=g.outputs[B];w={satoshis:t.satoshis,txid:g.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return w&&(w.satoshis=g.outputs[g.outputs.length-1].satoshis,w.txid=g.id("hex")),{tx:g,spentOutpoints:g.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:w}},F=async o=>{const{protocol:n,tokenID:a,utxos:c,paymentPk:u,listing:f,ordAddress:d,changeAddress:l,additionalPayments:h=[],satsPerKb:y=p}=o,b=new i(y),x=new r;x.addInput(k(f.listingUtxo,(new T).purchaseListing(f.listingUtxo.satoshis,e.fromHex(Buffer.from(f.listingUtxo.script,"base64").toString("hex")))));const S={p:"bsv-20",op:"transfer",amt:f.listingUtxo.amt};let B,I;if(n===m.BSV20)B=w({},S,{tick:a});else{if(n!==m.BSV21)throw new Error("Invalid protocol");B=w({},S,{id:a})}x.addOutput({satoshis:1,lockingScript:(new g).lock(d,{dataB64:Buffer.from(JSON.stringify(B)).toString("base64"),contentType:"application/bsv-20"})});for(const o of h)x.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const v=l||u.toAddress().toString(),O=(new t).lock(v);x.addOutput({lockingScript:O,change:!0});let $=0n;const A=x.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let E=0;for(const o of c){const n=k(o,(new t).unlock(u,"all",!0,o.satoshis,e.fromBinary(s.toArray(o.script,"base64"))));if(x.addInput(n),$+=BigInt(o.satoshis),E=await b.computeFee(x),$>=A+BigInt(E))break}if($<A+BigInt(E))throw new Error(`Not enough funds to purchase listing. Total sats in: ${$}, Total sats out: ${A}, Fee: ${E}`);await x.fee(b),await x.sign();const P=x.outputs.findIndex(t=>t.change);if(-1!==P){const t=x.outputs[P];I={satoshis:t.satoshis,txid:x.id("hex"),vout:P,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return I&&(I.satoshis=x.outputs[x.outputs.length-1].satoshis,I.txid=x.id("hex")),{tx:x,spentOutpoints:x.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:I}};export{T as OrdLock,g as OrdP2PKH,y as RoytaltyType,m as TokenType,_ as cancelOrdListings,N as createOrdListings,O as createOrdinals,S as fetchNftUtxos,x as fetchPayUtxos,B as fetchTokenUtxos,F as purchaseOrdListings,$ as sendOrdinals,A as sendUtxos,v as stringifyMetaData,E as transferOrdTokens,P as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
