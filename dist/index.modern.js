import{P2PKH as t,LockingScript as o,Script as n,Utils as s,fromUtxo as e,SatoshisPerKilobyte as r,Transaction as i,OP as a,BigNumber as c,UnlockingScript as u,TransactionSignature as d,defaultHttpClient as f}from"@bsv/sdk";import{toToken as l,toTokenSat as p,ReturnTypes as h}from"satoshi-token";import{Sigma as g}from"sigma-protocol";import*as m from"image-size";const w=t=>Buffer.from(t).toString("hex"),y="1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5",b=10,k="https://ordinals.gorillapool.io/api";class S extends t{lock(n,s,e){let r="";if(void 0!==(null==s?void 0:s.dataB64)&&void 0!==(null==s?void 0:s.contentType)){const t=w("ord"),o=Buffer.from(s.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=w(s.contentType);if(!n)throw new Error("Invalid media type");r=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let i=`${r?`${r} `:""}${(new t).lock(n).toASM()}`;if(e&&(!e.app||!e.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=e&&e.app&&null!=e&&e.type){i=`${i?`${i} `:""}OP_RETURN ${w(y)} ${w("SET")}`;for(const[t,o]of Object.entries(e))"cmd"!==t&&(i=`${i} ${w(t)} ${w(o)}`)}return o.fromASM(i)}}function B(){return B=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var s in n)({}).hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},B.apply(null,arguments)}var I,x,v,O;!function(t){t.SmallestFirst="smallest",t.LargestFirst="largest",t.RetainOrder="retain",t.Random="random"}(I||(I={})),function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(x||(x={})),function(t){t.Paymail="paymail",t.Address="address",t.Script="script"}(v||(v={})),function(t){t.All="all",t.Needed="needed"}(O||(O={}));const $=2n**64n-1n,{fromBase58Check:A}=s,E=(t,o)=>e(B({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o),N=async(o,n="base64")=>{const s=`${k}/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:s});const e=await fetch(s);if(!e.ok)throw new Error("Error fetching pay utxos");let r=await e.json();r=r.filter(t=>1!==t.satoshis&&!C(t));const i=A(o),a=(new t).lock(i.data);return r=r.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:"hex"===n||"base64"===n?Buffer.from(a.toBinary()).toString(n):a.toASM()})),r},P=async(t,o,s=10,e=0,r="base64")=>{let i=`${k}/txos/address/${t}/unspent?limit=${s}&offset=${e}&`;o&&(i+=`q=${Buffer.from(JSON.stringify({map:{subTypeData:{collectionId:o}}})).toString("base64")}`);const a=await fetch(i);if(!a.ok)throw new Error(`Error fetching NFT utxos for ${t}`);let c=await a.json();c=c.filter(t=>{var o;return 1===t.satoshis&&!(null!=(o=t.data)&&o.list)});const u=c.map(t=>`${t.txid}_${t.vout}`),d=await fetch(`${k}/txos/outpoints?script=true`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify([...u])});if(!d.ok)throw new Error(`Error fetching NFT scripts for ${t}`);return c=(await d.json()||[]).map(t=>{let s=t.script;"hex"===r?s=Buffer.from(s,"base64").toString("hex"):"asm"===r&&(s=n.fromHex(Buffer.from(s,"base64").toString("hex")).toASM());const e={origin:t.origin.outpoint,script:s,vout:t.vout,txid:t.txid,satoshis:1};return o&&(e.collectionId=o),e}),c},T=async(t,o,n,s=10,e=0)=>{const r=`${k}/bsv20/${n}/${t===x.BSV20?"tick":"id"}/${o}?bsv20=true&listing=false&limit=${s}&offset=${e}`,i=await fetch(r);if(!i.ok)throw new Error(`Error fetching ${t} utxos`);let a=await i.json();return a=a.map(t=>({amt:t.amt,script:t.script,vout:t.vout,txid:t.txid,id:o,satoshis:1})),a},C=t=>!!t.lock,_=(t,o,n,s={})=>{const{inputStrategy:e=I.RetainOrder,outputStrategy:r=I.RetainOrder}=s,i=[...t].sort((t,o)=>{if(e===I.RetainOrder)return 0;const n=BigInt(t.amt),s=BigInt(o.amt);switch(e){case I.SmallestFirst:return Number(n-s);case I.LargestFirst:return Number(s-n);case I.Random:return Math.random()-.5;default:return 0}});let a=0;const c=[];for(const t of i)if(c.push(t),a+=l(t.amt,n),a>=o&&o>0)break;return r!==I.RetainOrder&&c.sort((t,o)=>{const n=BigInt(t.amt),s=BigInt(o.amt);switch(r){case I.SmallestFirst:return Number(n-s);case I.LargestFirst:return Number(s-n);case I.Random:return Math.random()-.5;default:return 0}}),{selectedUtxos:c,totalSelected:a,isEnough:a>=o}},F=async(t,o)=>{const n=null==o?void 0:o.idKey,s=null==o?void 0:o.keyHost;if(n){const o=new g(t),{signedTx:s}=o.sign(n);return s}if(s){const n=null==o?void 0:o.authToken,e=new g(t);try{const{signedTx:t}=await e.remoteSign(s,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${s} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},D=t=>{if(!t)return;const o={app:t.app,type:t.type};for(const[n,s]of Object.entries(t))void 0!==s&&(o[n]="string"==typeof s?s:Array.isArray(s)||"object"==typeof s?JSON.stringify(s):String(s));return o},L=async o=>{const{utxos:e,destinations:a,paymentPk:c,changeAddress:u,satsPerKb:d=b,metaData:f,signer:l,additionalPayments:p=[]}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const h=new r(d);let g,m=new i;for(const t of a){if(!t.inscription)throw new Error("Inscription is required for all destinations");if(f)for(const t of Object.keys(f))void 0===f[t]&&delete f[t];m.addOutput({satoshis:1,lockingScript:(new S).lock(t.address,t.inscription,D(f))})}for(const o of p)m.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const w=u||c.toAddress().toString(),y=(new t).lock(w);m.addOutput({lockingScript:y,change:!0});let k=0n;const B=m.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);if(l){const o=e.pop();m.addInput(E(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))))),k+=BigInt(o.satoshis),m=await F(m,l)}let I=0;for(const o of e){if(k>=B+BigInt(I))break;const e=E(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));m.addInput(e),k+=BigInt(o.satoshis),I=await h.computeFee(m)}if(k<B+BigInt(I))throw new Error(`Not enough funds to create ordinals. Total sats in: ${k}, Total sats out: ${B}, Fee: ${I}`);await m.fee(h),await m.sign();const x=m.outputs.findIndex(t=>t.change);if(-1!==x){const t=m.outputs[x];g={satoshis:t.satoshis,txid:m.id("hex"),vout:x,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return g&&(g.satoshis=m.outputs[m.outputs.length-1].satoshis,g.txid=m.id("hex")),{tx:m,spentOutpoints:e.map(t=>`${t.txid}_${t.vout}`),payChange:g}},R=async o=>{o.satsPerKb||(o.satsPerKb=b),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const e=new r(o.satsPerKb);let a=new i;const c=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const e=E(t,(new S).unlock(o.ordPk,"all",!0,t.satoshis,n.fromBinary(s.toArray(t.script,"base64"))));c.push(`${t.txid}_${t.vout}`),a.addInput(e)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of o.destinations){var u,d;let s;s=null!=(u=n.inscription)&&u.dataB64&&null!=(d=n.inscription)&&d.contentType?(new S).lock(n.address,n.inscription,D(o.metaData)):(new t).lock(n.address),a.addOutput({satoshis:1,lockingScript:s})}for(const n of o.additionalPayments)a.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});let f;const l=o.changeAddress||o.paymentPk.toAddress().toString(),p=(new t).lock(l);a.addOutput({lockingScript:p,change:!0});let h=0n;const g=a.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let m=0;for(const r of o.paymentUtxos){const i=E(r,(new t).unlock(o.paymentPk,"all",!0,r.satoshis,n.fromBinary(s.toArray(r.script,"base64"))));if(c.push(`${r.txid}_${r.vout}`),a.addInput(i),h+=BigInt(r.satoshis),m=await e.computeFee(a),h>=g+BigInt(m))break}if(h<g)throw new Error("Not enough ordinals to send");o.signer&&(a=await F(a,o.signer)),await a.fee(e),await a.sign();const w=a.outputs.findIndex(t=>t.change);if(-1!==w){const t=a.outputs[w];f={satoshis:t.satoshis,txid:a.id("hex"),vout:w,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return f&&(f.satoshis=a.outputs[a.outputs.length-1].satoshis,f.txid=a.id("hex")),{tx:a,spentOutpoints:c,payChange:f}},U=async o=>{const{utxos:e,paymentPk:a,payments:c,satsPerKb:u=b,changeAddress:d=a.toAddress().toString(),metaData:f}=o,l=new r(u),p=new i;for(const t of c){const o={satoshis:t.amount,lockingScript:(new S).lock(t.to,void 0,f)};p.addOutput(o)}let h=0n;const g=p.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let m,w=0;for(const o of e){const e=E(o,(new t).unlock(a,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(p.addInput(e),h+=BigInt(o.satoshis),w=await l.computeFee(p),h>=g+w)break}if(h<g+w)throw new Error(`Not enough funds to send. Total sats in: ${h}, Total sats out: ${g}, Fee: ${w}`);if(h>g+w){const o=(new t).lock(d),n={lockingScript:o,change:!0};m={txid:"",vout:p.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},p.addOutput(n)}else h<g+w&&console.log("No change needed");await p.fee(l),await p.sign();const y=p.outputs.findIndex(t=>t.change);if(-1!==y){const t=p.outputs[y];m={satoshis:t.satoshis,txid:p.id("hex"),vout:y,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return m&&(m.satoshis=p.outputs[p.outputs.length-1].satoshis,m.txid=p.id("hex")),{tx:p,spentOutpoints:e.map(t=>`${t.txid}_${t.vout}`),payChange:m}},M=async o=>{const{protocol:e,tokenID:a,utxos:c,inputTokens:u,distributions:d,paymentPk:f,ordPk:l,changeAddress:g,tokenChangeAddress:m,satsPerKb:w=b,metaData:y,signer:k,decimals:I,additionalPayments:v=[],burn:$=!1,tokenInputMode:A=O.Needed,splitConfig:N={outputs:1,omitMetaData:!1}}=o;if(!u.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");let P=0n,T=0n,C=0n;const _=d.reduce((t,o)=>t+p(o.tokens,I,h.BigInt),0n),L=new r(w);let R,U=new i;if(A===O.All)R=u,T=u.reduce((t,o)=>t+BigInt(o.amt),0n);else{R=[];for(const t of u)if(R.push(t),T+=BigInt(t.amt),T>=_)break;if(T<_)throw new Error("Not enough tokens to satisfy the transfer amount")}for(const t of R){const o=s.toArray(t.script,"base64"),e=n.fromBinary(o);U.addInput(E(t,(new S).unlock(l,"all",!0,t.satoshis,e)))}if(y)for(const t of Object.keys(y))void 0===y[t]&&delete y[t];for(const t of d){const o=p(t.tokens,I,h.BigInt);console.log({distTokenSat:o});const n={p:"bsv-20",op:$?"burn":"transfer",amt:o.toString()};let s;if(e===x.BSV20)s=B({},n,{tick:a});else{if(e!==x.BSV21)throw new Error("Invalid protocol");s=B({},n,{id:a})}U.addOutput({satoshis:1,lockingScript:(new S).lock(t.address,{dataB64:Buffer.from(JSON.stringify(s)).toString("base64"),contentType:"application/bsv-20"},t.omitMetaData?void 0:D(y))}),C+=o}if(P=T-C,P<0n)throw new Error("Not enough tokens to send");let M,K=[];console.log({changeTsats:P}),P>0n&&(K=j(U,P,e,a,m||l.toAddress().toString(),l,y,N,I));for(const o of v)U.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const V=g||f.toAddress().toString(),q=(new t).lock(V);U.addOutput({lockingScript:q,change:!0});let H=0n;const J=U.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let X=0;for(const o of c){const e=E(o,(new t).unlock(f,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(U.addInput(e),H+=BigInt(o.satoshis),X=await L.computeFee(U),H>=J+BigInt(X))break}if(H<J+BigInt(X))throw new Error(`Not enough funds to transfer tokens. Total sats in: ${H}, Total sats out: ${J}, Fee: ${X}`);k&&(U=await F(U,k)),await U.fee(L),await U.sign();const W=U.id("hex");for(const t of K)t.txid=W;const G=U.outputs.findIndex(t=>t.change);if(-1!==G){const t=U.outputs[G];M={satoshis:t.satoshis,txid:W,vout:G,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return M&&(M.satoshis=U.outputs[U.outputs.length-1].satoshis,M.txid=U.id("hex")),{tx:U,spentOutpoints:U.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:M,tokenChange:K}},j=(t,o,n,s,e,r,i,a,c)=>{const u=[],d=void 0!==a.threshold?p(a.threshold,c,h.BigInt):void 0,f=a.outputs,l=o;let g;console.log({splitChangeAmt:l}),void 0!==d&&d>0n?(g=l/d,g=BigInt(Math.min(Number(g),f))):g=BigInt(f),g=BigInt(Math.max(Number(g),1));const m=l/g;let w=l%g;for(let o=0n;o<g;o++){let o=m;w>0n&&(o+=1n,w-=1n);const c={p:"bsv-20",op:"transfer",amt:o.toString()};let d;if(n===x.BSV20)d=B({},c,{tick:s});else{if(n!==x.BSV21)throw new Error("Invalid protocol");d=B({},c,{id:s})}const f=(new S).lock(e||r.toAddress().toString(),{dataB64:Buffer.from(JSON.stringify(d)).toString("base64"),contentType:"application/bsv-20"},a.omitMetaData?void 0:D(i)),l=t.outputs.length;t.addOutput({lockingScript:f,satoshis:1}),u.push({id:s,satoshis:1,script:Buffer.from(f.toBinary()).toString("base64"),txid:"",vout:l,amt:o.toString()})}return u},K=(t,o)=>{try{if("collection"===t){const t=o;if(!t.description)return new Error("Collection description is required");if(!t.quantity)return new Error("Collection quantity is required");if(t.rarityLabels){if(!Array.isArray(t.rarityLabels))return new Error("Rarity labels must be an array");if(!t.rarityLabels.every(t=>Object.values(t).every(t=>"string"==typeof t)))return new Error(`Invalid rarity labels ${t.rarityLabels}`)}if(t.traits){if("object"!=typeof t.traits)return new Error("Collection traits must be an object");if(t.traits&&!Object.keys(t.traits).every(o=>"string"==typeof o&&"object"==typeof t.traits[o]))return new Error("Collection traits must be a valid CollectionTraits object")}}if("collectionItem"===t){const t=o;if(!t.collectionId)return new Error("Collection id is required");if(!t.collectionId.includes("_"))return new Error("Collection id must be a valid outpoint");if(64!==t.collectionId.split("_")[0].length)return new Error("Collection id must contain a valid txid");if(Number.isNaN(Number.parseInt(t.collectionId.split("_")[1])))return new Error("Collection id must contain a valid vout");if(t.mintNumber&&"number"!=typeof t.mintNumber)return new Error("Mint number must be a number");if(t.rank&&"number"!=typeof t.rank)return new Error("Rank must be a number");if(t.rarityLabel&&"string"!=typeof t.rarityLabel)return new Error("Rarity label must be a string");if(t.traits&&"object"!=typeof t.traits)return new Error("Traits must be an object");if(t.attachments&&!Array.isArray(t.attachments))return new Error("Attachments must be an array")}return}catch(t){return new Error("Invalid JSON data")}};class V{lock(o,e,r,i){const a=s.fromBase58Check(o).data,c=s.fromBase58Check(e).data;let u=new n;if(void 0!==(null==i?void 0:i.dataB64)&&void 0!==(null==i?void 0:i.contentType)){const t=w("ord"),o=Buffer.from(i.dataB64,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const s=w(i.contentType);if(!s)throw new Error("Invalid media type");u=n.fromASM(`OP_0 OP_IF ${t} OP_1 ${s} OP_0 ${o} OP_ENDIF`)}return u.writeScript(n.fromHex("2097dfd76851bf465e8f715593b217714858bbe9570ff3bd5e33840a34e20ff0262102ba79df5f8ae7604a9830f03c7933028186aede0675a16f025dc4f8be8eec0382201008ce7480da41702918d1ec8e6849ba32b4d65b1e40dc669c31a1e6306b266c0000")).writeBin(a).writeBin(V.buildOutput(r,(new t).lock(c).toBinary())).writeScript(n.fromHex("615179547a75537a537a537a0079537a75527a527a7575615579008763567901c161517957795779210ac407f0e4bd44bfc207355a778b046225a7068fc59ee7eda43ad905aadbffc800206c266b30e6a1319c66dc401e5bd6b432ba49688eecd118297041da8074ce081059795679615679aa0079610079517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01007e81517a75615779567956795679567961537956795479577995939521414136d08c5ed2bf3ba048afe6dcaebafeffffffffffffffffffffffffffffff00517951796151795179970079009f63007952799367007968517a75517a75517a7561527a75517a517951795296a0630079527994527a75517a6853798277527982775379012080517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f517f7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e7c7e01205279947f7754537993527993013051797e527e54797e58797e527e53797e52797e57797e0079517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a75517a756100795779ac517a75517a75517a75517a75517a75517a75517a75517a75517a7561517a75517a756169587951797e58797eaa577961007982775179517958947f7551790128947f77517a75517a75618777777777777777777767557951876351795779a9876957795779ac777777777777777767006868"))}cancelListing(o,n="all",s=!1,e,r){const i=(new t).unlock(o,n,s,e,r);return{sign:async function(t,o){return(await i.sign(t,o)).writeOpCode(a.OP_1)},estimateLength:async function(){return 107}}}purchaseListing(t,o){const n={sign:async function(n,e){var r;if(n.outputs.length<2)throw new Error("Malformed transaction");const i=(new u).writeBin(V.buildOutput(n.outputs[0].satoshis||0,n.outputs[0].lockingScript.toBinary()));if(n.outputs.length>2){const t=new s.Writer;for(const o of n.outputs.slice(2))t.write(V.buildOutput(o.satoshis||0,o.lockingScript.toBinary()));i.writeBin(t.toArray())}else i.writeOpCode(a.OP_0);const c=n.inputs[e];let f=t;if(!f&&c.sourceTransaction)f=c.sourceTransaction.outputs[c.sourceOutputIndex].satoshis;else if(!t)throw new Error("sourceTransaction or sourceSatoshis is required");const l=c.sourceTXID||(null==(r=c.sourceTransaction)?void 0:r.id("hex"));let p=o;var h;p||(p=null==(h=c.sourceTransaction)?void 0:h.outputs[c.sourceOutputIndex].lockingScript);const g=d.format({sourceTXID:l,sourceOutputIndex:c.sourceOutputIndex,sourceSatoshis:f,transactionVersion:n.version,otherInputs:[],inputIndex:e,outputs:n.outputs,inputSequence:c.sequence,subscript:p,lockTime:n.lockTime,scope:d.SIGHASH_ALL|d.SIGHASH_ANYONECANPAY|d.SIGHASH_FORKID});return i.writeBin(g).writeOpCode(a.OP_0)},estimateLength:async function(t,o){return(await n.sign(t,o)).toBinary().length}};return n}static buildOutput(t,o){const n=new s.Writer;return n.writeUInt64LEBn(new c(t)),n.writeVarIntNum(o.length),n.write(o),n.toArray()}}const{toArray:q}=s,H=async o=>{const{utxos:e,listings:a,paymentPk:c,ordPk:u,changeAddress:d,satsPerKb:f=b,additionalPayments:l=[]}=o,p=new r(f),h=new i;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of a){h.addOutput({satoshis:1,lockingScript:(new V).lock(t.ordAddress,t.payAddress,t.price)});const o=q(t.listingUtxo.script,"base64"),s=n.fromBinary(o);h.addInput(E(t.listingUtxo,(new S).unlock(u,"all",!0,t.listingUtxo.satoshis,s)))}for(const o of l)h.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let g;const m=(new t).lock(d||c.toAddress().toString());h.addOutput({lockingScript:m,change:!0});let w=0n;const y=h.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let k=0;for(const o of e){const e=E(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(h.addInput(e),w+=BigInt(o.satoshis),k=await p.computeFee(h),w>=y+BigInt(k))break}if(w<y+BigInt(k))throw new Error(`Not enough funds to create ordinal listings. Total sats in: ${w}, Total sats out: ${y}, Fee: ${k}`);await h.fee(p),await h.sign();const B=h.outputs.findIndex(t=>t.change);if(-1!==B){const t=h.outputs[B];g={satoshis:t.satoshis,txid:h.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return g&&(g.satoshis=h.outputs[h.outputs.length-1].satoshis,g.txid=h.id("hex")),{tx:h,spentOutpoints:h.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:g}},J=async o=>{const{utxos:e,protocol:a,tokenID:c,ordPk:u,paymentPk:d,additionalPayments:f=[],changeAddress:l,tokenChangeAddress:g,inputTokens:m,listings:w,decimals:y,satsPerKb:k=b}=o;if(w.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!m.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");let I=0n,v=0n,O=0n;if(!m.every(t=>t.id===c))throw new Error("Input tokens do not match the provided tokenID");const $=new r(k),A=new i;for(const t of w){const o=p(t.tokens,y,h.BigInt),n={p:"bsv-20",op:"transfer",amt:o.toString()};let s;if(a===x.BSV20)s=B({},n,{tick:c});else{if(a!==x.BSV21)throw new Error("Invalid protocol");s=B({},n,{id:c})}A.addOutput({satoshis:1,lockingScript:(new V).lock(t.ordAddress,t.payAddress,t.price,{dataB64:Buffer.from(JSON.stringify(s)).toString("base64"),contentType:"application/bsv-20"})}),O+=o}for(const t of m)A.addInput(E(t,(new S).unlock(u,"all",!0,t.satoshis,n.fromBinary(q(t.script,"base64"))))),v+=BigInt(t.amt);let N,P;if(I=v-O,I<0n)throw new Error("Not enough tokens to send");if(I>0n){const t={p:"bsv-20",op:"transfer",amt:I.toString()};let o;if(a===x.BSV20)o=B({},t,{tick:c});else{if(a!==x.BSV21)throw new Error("Invalid protocol");o=B({},t,{id:c})}const n=(new S).lock(g,{dataB64:Buffer.from(JSON.stringify(o)).toString("base64"),contentType:"application/bsv-20"}),s=A.outputs.length;A.addOutput({lockingScript:n,satoshis:1}),N=[{id:c,satoshis:1,script:Buffer.from(n.toBinary()).toString("base64"),txid:"",vout:s,amt:I.toString()}]}for(const o of f)A.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const T=l||d.toAddress().toString(),C=(new t).lock(T);A.addOutput({lockingScript:C,change:!0});let _=0n;const F=A.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let D=0;for(const o of e){const e=E(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(A.addInput(e),_+=BigInt(o.satoshis),D=await $.computeFee(A),_>=F+BigInt(D))break}if(_<F+BigInt(D))throw new Error(`Not enough funds to create token listings. Total sats in: ${_}, Total sats out: ${F}, Fee: ${D}`);await A.fee($),await A.sign();const L=A.id("hex");N&&(N=N.map(t=>B({},t,{txid:L})));const R=A.outputs.findIndex(t=>t.change);if(-1!==R){const t=A.outputs[R];P={satoshis:t.satoshis,txid:L,vout:R,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return P&&(P.satoshis=A.outputs[A.outputs.length-1].satoshis,P.txid=A.id("hex")),{tx:A,spentOutpoints:A.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:P,tokenChange:N}},X=async o=>{const{utxos:e,listingUtxos:a,ordPk:c,paymentPk:u,changeAddress:d,additionalPayments:f=[],satsPerKb:l=b}=o;a.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");const p=new r(l),h=new i;for(const o of a)h.addInput(E(o,(new V).cancelListing(c,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))))),h.addOutput({satoshis:1,lockingScript:(new t).lock(c.toAddress().toString())});for(const o of f)h.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let g;const m=d||u.toAddress().toString(),w=(new t).lock(m);h.addOutput({lockingScript:w,change:!0});let y=0n;const k=h.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let S=0;for(const o of e){const e=E(o,(new t).unlock(u,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(h.addInput(e),y+=BigInt(o.satoshis),S=await p.computeFee(h),y>=k+BigInt(S))break}if(y<k+BigInt(S))throw new Error(`Not enough funds to cancel ordinal listings. Total sats in: ${y}, Total sats out: ${k}, Fee: ${S}`);await h.fee(p),await h.sign();const B=h.outputs.findIndex(t=>t.change);if(-1!==B){const t=h.outputs[B];g={satoshis:t.satoshis,txid:h.id("hex"),vout:B,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return g&&(g.satoshis=h.outputs[h.outputs.length-1].satoshis,g.txid=h.id("hex")),{tx:h,spentOutpoints:h.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:g}},W=async o=>{const{protocol:e,tokenID:a,ordAddress:c,changeAddress:u,paymentPk:d,ordPk:f,additionalPayments:l,listingUtxos:p,utxos:h,satsPerKb:g=b}=o;let m=0;if(p.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead."),!p.every(t=>t.id===a))throw new Error("Input tokens do not match the provided tokenID");const w=new r(g),y=new i;for(const t of p)y.addInput(E(t,(new V).cancelListing(f,"all",!0,t.satoshis,n.fromBinary(s.toArray(t.script,"base64"))))),m+=Number.parseInt(t.amt);const k={p:"bsv-20",op:"transfer",amt:m.toString()};let I;if(e===x.BSV20)I=B({},k,{tick:a});else{if(e!==x.BSV21)throw new Error("Invalid protocol");I=B({},k,{id:a})}const v={address:c||f.toAddress().toString(),inscription:{dataB64:Buffer.from(JSON.stringify(I)).toString("base64"),contentType:"application/bsv-20"}},O=(new S).lock(v.address,v.inscription);y.addOutput({satoshis:1,lockingScript:O});for(const o of l)y.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let $;const A=u||d.toAddress().toString(),N=(new t).lock(A);y.addOutput({lockingScript:N,change:!0});let P=0n;const T=y.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let C=0;for(const o of h){const e=E(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(y.addInput(e),P+=BigInt(o.satoshis),C=await w.computeFee(y),P>=T+BigInt(C))break}if(P<T+BigInt(C))throw new Error(`Not enough funds to cancel token listings. Total sats in: ${P}, Total sats out: ${T}, Fee: ${C}`);await y.fee(w),await y.sign();const _=[{amt:m.toString(),script:Buffer.from(O.toHex(),"hex").toString("base64"),txid:y.id("hex"),vout:0,id:a,satoshis:1}],F=y.outputs.findIndex(t=>t.change);if(-1!==F){const t=y.outputs[F];$={satoshis:t.satoshis,txid:y.id("hex"),vout:F,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return $&&($.satoshis=y.outputs[y.outputs.length-1].satoshis,$.txid=y.id("hex")),{tx:y,spentOutpoints:y.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:$,tokenChange:_}},G=async(t,o)=>{throw new Error("Not implemented")},Y=async e=>{const{utxos:a,paymentPk:c,listing:u,ordAddress:d,changeAddress:f,additionalPayments:l=[],satsPerKb:p=b,royalties:h=[],metaData:g}=e,m=new r(p),w=new i;w.addInput(E(u.listingUtxo,(new V).purchaseListing(1,n.fromBinary(s.toArray(u.listingUtxo.script,"base64"))))),w.addOutput({satoshis:1,lockingScript:(new S).lock(d,void 0,g)});const y=new s.Reader(s.toArray(u.payout,"base64")),k=y.readUInt64LEBn().toNumber(),B=y.readVarIntNum(),I=y.read(B),x=o.fromBinary(I);w.addOutput({satoshis:k,lockingScript:x});for(const o of l)w.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});for(const o of h){let e;const r=Math.floor(Number(o.percentage)*k);switch(o.type){case v.Paymail:e=await G();break;case v.Script:e=n.fromBinary(s.toArray(o.destination,"base64"));break;case v.Address:e=(new t).lock(o.destination);break;default:throw new Error("Invalid royalty type")}if(!e)throw new Error("Invalid royalty destination");w.addOutput({satoshis:r,lockingScript:e})}let O;const $=f||c.toAddress().toString(),A=(new t).lock($);w.addOutput({lockingScript:A,change:!0});let N=0n;const P=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let T=0;for(const o of a){const e=E(o,(new t).unlock(c,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(w.addInput(e),N+=BigInt(o.satoshis),T=await m.computeFee(w),N>=P+BigInt(T))break}if(N<P+BigInt(T))throw new Error(`Not enough funds to purchase ordinal listing. Total sats in: ${N}, Total sats out: ${P}, Fee: ${T}`);await w.fee(m),await w.sign();const C=w.outputs.findIndex(t=>t.change);if(-1!==C){const t=w.outputs[C];O={satoshis:t.satoshis,txid:w.id("hex"),vout:C,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return O&&(O.satoshis=w.outputs[w.outputs.length-1].satoshis,O.txid=w.id("hex")),{tx:w,spentOutpoints:w.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:O}},z=async e=>{const{protocol:a,tokenID:c,utxos:u,paymentPk:d,listingUtxo:f,ordAddress:l,changeAddress:p,satsPerKb:h=b,additionalPayments:g=[],metaData:m}=e,w=new r(h),y=new i;y.addInput(E(f,(new V).purchaseListing(1,n.fromBinary(s.toArray(f.script,"base64")))));const k={p:"bsv-20",op:"transfer",amt:f.amt};let I;if(a===x.BSV20)I=B({},k,{tick:c});else{if(a!==x.BSV21)throw new Error("Invalid protocol");I=B({},k,{id:c})}const v=Buffer.from(JSON.stringify(I)).toString("base64");if(y.addOutput({satoshis:1,lockingScript:(new S).lock(l,{dataB64:v,contentType:"application/bsv-20"},m)}),!f.payout)throw new Error("Listing UTXO does not have a payout script");const O=new s.Reader(s.toArray(f.payout,"base64")),$=O.readUInt64LEBn().toNumber(),A=O.readVarIntNum(),N=O.read(A),P=o.fromBinary(N);y.addOutput({satoshis:$,lockingScript:P});for(const o of g)y.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});let T;const C=p||d.toAddress().toString(),_=(new t).lock(C);y.addOutput({lockingScript:_,change:!0});let F=0n;const D=y.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let L=0;for(const o of u){const e=E(o,(new t).unlock(d,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(y.addInput(e),F+=BigInt(o.satoshis),L=await w.computeFee(y),F>=D+BigInt(L))break}if(F<D+BigInt(L))throw new Error(`Not enough funds to purchase token listing. Total sats in: ${F}, Total sats out: ${D}, Fee: ${L}`);await y.fee(w),await y.sign();const R=y.outputs.findIndex(t=>t.change);if(-1!==R){const t=y.outputs[R];T={satoshis:t.satoshis,txid:y.id("hex"),vout:R,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return T&&(T.satoshis=y.outputs[y.outputs.length-1].satoshis,T.txid=y.id("hex")),{tx:y,spentOutpoints:y.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:T}};m.disableFS(!0);const Q=m.default,Z=new Error("Image must be a square image with dimensions <= 400x400"),tt=new Error("Image must be a square image"),ot=new Error("Error processing image"),nt=new Error("Image dimensions are undefined"),st=async o=>{const{symbol:e,icon:a,decimals:c,utxos:u,initialDistribution:d,paymentPk:f,destinationAddress:l,changeAddress:p,satsPerKb:h=b,additionalPayments:g=[]}=o,m=new r(h),w=new i;let y;if("string"==typeof a)y=a;else{const t=await(async t=>{const{dataB64:o,contentType:n}=t;if("image/svg+xml"===n)return(t=>{const o=Buffer.from(t,"base64").toString("utf-8"),n=o.match(/<svg[^>]*\s+width="([^"]+)"/),s=o.match(/<svg[^>]*\s+height="([^"]+)"/);if(!n||!s)return nt;const e=Number.parseInt(n[1],10),r=Number.parseInt(s[1],10);return Number.isNaN(e)||Number.isNaN(r)?nt:e!==r?tt:e>400||r>400?Z:null})(o);if((s=n)!=s)return ot;var s;try{const t=Buffer.from(o,"base64"),n=Q(t);return void 0===n.width||void 0===n.height?nt:n.width!==n.height?tt:n.width>400||n.height>400?Z:null}catch(t){return ot}})(a);if(t)throw t;const o=(new S).lock(l,a);w.addOutput({satoshis:1,lockingScript:o}),y="_0"}if(!(t=>{if(!t.includes("_")||t.endsWith("_"))return!1;const o=Number.parseInt(t.split("_")[1]);return!(Number.isNaN(o)||!t.startsWith("_")&&64!==t.split("_")[0].length)})(y))throw new Error("Invalid icon format. Must be either outpoint (format: txid_vout) or relative output index of the icon (format _vout). examples: ecb483eda58f26da1b1f8f15b782b1186abdf9c6399a1c3e63e0d429d5092a41_0 or _1");const k={p:"bsv-20",op:"deploy+mint",sym:e,icon:y,amt:(c?BigInt(d.tokens)*10n**BigInt(c):BigInt(d.tokens)).toString()};c&&(k.dec=c.toString());const B=Buffer.from(JSON.stringify(k)).toString("base64"),I={satoshis:1,lockingScript:(new S).lock(l,{dataB64:B,contentType:"application/bsv-20"})};w.addOutput(I);for(const o of g){const n={satoshis:o.amount,lockingScript:(new t).lock(o.to)};w.addOutput(n)}let x=0n;const v=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n);let O,$=0;for(const o of u){const e=E(o,(new t).unlock(f,"all",!0,o.satoshis,n.fromBinary(s.toArray(o.script,"base64"))));if(w.addInput(e),x+=BigInt(o.satoshis),$=await m.computeFee(w),x>=v+BigInt($))break}if(x<v+BigInt($))throw new Error(`Not enough funds to deploy token. Total sats in: ${x}, Total sats out: ${v}, Fee: ${$}`);const A=p||f.toAddress().toString(),N=(new t).lock(A);w.addOutput({lockingScript:N,change:!0}),await w.fee(m),await w.sign();const P=w.outputs.findIndex(t=>t.change);if(-1!==P){const t=w.outputs[P];O={satoshis:t.satoshis,txid:w.id("hex"),vout:P,script:Buffer.from(t.lockingScript.toBinary()).toString("base64")}}return{tx:w,spentOutpoints:w.inputs.map(t=>`${t.sourceTXID}_${t.sourceOutputIndex}`),payChange:O}},et=async t=>{const o=new i,e=[],{ordinals:r,metaData:a}=t;for(const i of r){if(1!==i.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const r=E(i,(new S).unlock(t.ordPk,"all",!0,i.satoshis,n.fromBinary(s.toArray(i.script,"base64"))));e.push(`${i.txid}_${i.vout}`),o.addInput(r)}if(a&&(!a.app||!a.type))throw new Error("MAP.app and MAP.type are required fields");let c="";if(null!=a&&a.app&&null!=a&&a.type){c=`OP_FALSE OP_RETURN ${w(y)} ${w("SET")}`;for(const[t,o]of Object.entries(a))"cmd"!==t&&(c=`${c} ${w(t)} ${w(o)}`)}return o.addOutput({satoshis:0,lockingScript:n.fromASM(c||"OP_FALSE OP_RETURN")}),await o.sign(),{tx:o,spentOutpoints:e}},rt=()=>new it;class it{constructor(t=f()){this.URL=void 0,this.httpClient=void 0,this.URL=`${k}/tx`,this.httpClient=t}async broadcast(t){const o={method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},data:{rawtx:s.toBase64(t.toBinary())}};try{var n,e;const t=await this.httpClient.request(this.URL,o);return t.ok?{status:"success",txid:t.data,message:"broadcast successful"}:{status:"error",code:null!=(n=t.status.toString())?n:"ERR_UNKNOWN",description:null!=(e=t.data.message)?e:"Unknown error"}}catch(t){return{status:"error",code:"500",description:t instanceof Error?t.message:"Internal Server Error"}}}}export{$ as MAX_TOKEN_SUPPLY,it as OneSatBroadcaster,V as OrdLock,S as OrdP2PKH,v as RoytaltyType,O as TokenInputMode,I as TokenSelectionStrategy,x as TokenType,et as burnOrdinals,X as cancelOrdListings,W as cancelOrdTokenListings,H as createOrdListings,J as createOrdTokenListings,L as createOrdinals,st as deployBsv21Token,P as fetchNftUtxos,N as fetchPayUtxos,T as fetchTokenUtxos,rt as oneSatBroadcaster,Y as purchaseOrdListing,z as purchaseOrdTokenListing,_ as selectTokenUtxos,R as sendOrdinals,U as sendUtxos,D as stringifyMetaData,M as transferOrdTokens,K as validateSubTypeData};
//# sourceMappingURL=index.modern.js.map
