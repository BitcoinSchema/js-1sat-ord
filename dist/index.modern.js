import{P2PKH as t,LockingScript as n,fromUtxo as o,SatoshisPerKilobyte as r,Transaction as e}from"@bsv/sdk";import{Sigma as i}from"sigma-protocol";const s=t=>Buffer.from(t).toString("hex");class a extends t{lock(o,r,e,i){let a="";if(void 0!==r&&void 0!==e){const t=s("ord"),n=Buffer.from(r,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=s(e);if(!o)throw new Error("Invalid media type");a=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let c=`${a?`${a} `:""}${(new t).lock(o).toASM()}`;if(i&&(!i.app||!i.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=i&&i.app&&null!=i&&i.type){c=`${c} OP_RETURN ${s("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${s("SET")}`;for(const[t,n]of Object.entries(i))"cmd"!==t&&(c=`${c} ${s(t)} ${s(n)}`)}return n.fromASM(c)}}function c(){return c=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var r in o)({}).hasOwnProperty.call(o,r)&&(t[r]=o[r])}return t},c.apply(null,arguments)}const d=(t,n)=>{const r=o(c({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return r.sourceTXID=t.txid,r},l=async(t,n)=>{const o=null==n?void 0:n.idKey,r=null==n?void 0:n.keyHost;if(o){const n=new i(t),{signedTx:r}=n.sign(o);return r}if(r){const o=null==n?void 0:n.authToken,e=new i(t);try{const{signedTx:t}=await e.remoteSign(r,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${r} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},f=async(n,o,i,s,c=10,f,u,p=[])=>{const w=new r(c);let g=new e;for(const o of n){const n=d(o,(new t).unlock(i));g.addInput(n)}o.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of o){if(!t.inscription)throw new Error("Inscription is required for all destinations");g.addOutput({satoshis:1,lockingScript:(new a).lock(t.address,t.inscription.dataB64,t.inscription.contentType,f)})}for(const n of p)g.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});return g.addOutput({lockingScript:(new t).lock(s||i.toAddress().toString()),change:!0}),u&&(g=await l(g,u)),await g.fee(w),await g.sign(),g},u=async(n,o,i,s,c,f,u=10,p,w,g=[],h=!0)=>{const m=new r(u);let S=new e;for(const t of o){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=d(t,(new a).unlock(s));S.addInput(n)}for(const o of n){const n=d(o,(new t).unlock(i));S.addInput(n)}if(h&&c.length!==o.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of c){var k,y;let o;o=null!=(k=n.inscription)&&k.dataB64&&null!=(y=n.inscription)&&y.contentType?(new a).lock(n.address,n.inscription.dataB64,n.inscription.contentType,p):(new t).lock(n.address),S.addOutput({satoshis:1,lockingScript:o})}for(const n of g)console.log("Additional payment",n),S.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});const v=(new t).lock(f||i.toAddress().toString());return S.addOutput({lockingScript:v,change:!0}),w&&(S=await l(S,w)),await S.fee(m),await S.sign(),S},p=async(n,o,i,s=10)=>{const a=new r(s),c=new e;for(const r of n){const n=d(r,(new t).unlock(o));c.addInput(n)}for(const n of i){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};c.addOutput(o)}const l=o.toAddress().toString(),f=(new t).lock(l);return c.addOutput({lockingScript:f,change:!0}),await c.fee(a),await c.sign(),c};var w;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(w||(w={}));const g=async(t,n,o,r,e,i,s,a,d,l=10,f,p,g=[])=>{let h=0n,m=0n,S=0n;if(!r.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of r)m+=BigInt(t.amt);for(const t of e)S+=BigInt(t.amt);if(m<S)throw new Error("Not enough tokens to send");if(h=m-S,h>0n){const t={address:d||s.toAddress().toString(),amt:h.toString()};e.push(t)}const k=e.map(o=>{const r={p:"bsv-20",op:"transfer",amt:o.amt};let e;if(t===w.BSV20)e=c({},r,{tick:n});else{if(t!==w.BSV21)throw new Error("Invalid protocol");e=c({},r,{id:n})}return{address:o.address,inscription:{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv-20"}}});return await u(o,r,i,s,k,a||i.toAddress().toString(),l,f,p,g,!1)};export{f as createOrdinals,u as sendOrdinals,p as sendUtxos,g as transferOrdTokens};
//# sourceMappingURL=index.modern.js.map
