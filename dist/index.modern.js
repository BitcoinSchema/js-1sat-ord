import{Script as t,Transaction as n,TxIn as o,P2PKHAddress as s,TxOut as e,SigHash as i}from"bsv-wasm";import{Buffer as r}from"buffer";import*as _ from"dotenv";import{Sigma as c}from"sigma-protocol";const g=t=>{for(var n=[],o=0,s=t.length;o<s;o++){var e=Number(t.charCodeAt(o)).toString(16);n.push(e)}return n.join("")};_.config();const a=(n,o,s,e)=>{let i="";if(void 0!==o&&void 0!==s){const t=g("ord"),n=r.from(o,"base64").toString("hex");i=`OP_0 OP_IF ${t} OP_1 ${g(s)} OP_0 ${n} OP_ENDIF`}let _=`${n.get_locking_script().to_asm_string()}${i?" "+i:""}`;if(e&&null!=e&&e.app&&null!=e&&e.type){_=`${_} OP_RETURN ${g("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${g("SET")}`;for(const[t,n]of Object.entries(e))"cmd"!==t&&(_=`${_} ${g(t)} ${g(n)}`)}return t.from_asm_string(_)},u=async(i,_,c,g)=>{let u=new n(1,0),l=new o(r.from(i.txid,"hex"),i.vout,t.from_asm_string(i.script));u.add_input(l);const m=a(s.from_string(_),null==c?void 0:c.dataB64,null==c?void 0:c.contentType,g);let p=new e(BigInt(1),m);return u.add_output(p),u},l=async(_,g,u,l,m,p,f,d)=>{let h=new n(1,0),w=new o(r.from(_.txid,"hex"),_.vout,t.from_asm_string(""));h.add_input(w);const x=a(s.from_string(g),p.dataB64,p.contentType,f);let y=new e(BigInt(1),x);h.add_output(y);const I=s.from_string(l).get_locking_script();let $=new e(BigInt(1),I);const B=Math.ceil(m*(h.get_size()+$.to_bytes().byteLength)),k=_.satoshis-1-B;if(k<0)throw new Error("Inadequate satoshis for fee");if(k>0){let t=new e(BigInt(k),I);h.add_output(t)}const v=null==d?void 0:d.idKey,b=null==d?void 0:d.keyHost;if(v){const t=new c(h),{signedTx:n}=t.sign(v);h=n}else if(b){const t=null==d?void 0:d.authToken,n=new c(h);try{const{signedTx:o}=await n.remoteSign(b,t);h=o}catch(t){throw console.log(t),new Error("Remote signing to "+b+" failed")}}const O=h.sign(u,i.ALL|i.FORKID,0,t.from_asm_string(_.script),BigInt(_.satoshis));return w.set_unlocking_script(t.from_asm_string(`${O.to_hex()} ${u.to_public_key().to_hex()}`)),h.set_input(0,w),h},m=async(_,c,g,u,l,m,p,f,d)=>{let h=new n(1,0),w=new o(r.from(c.txid,"hex"),c.vout,t.from_asm_string(""));h.add_input(w);let x,y=new o(r.from(_.txid,"hex"),_.vout,t.from_asm_string(""));h.add_input(y);const I=s.from_string(p);x=null!=f&&f.dataB64&&null!=f&&f.contentType?a(I,f.dataB64,f.contentType,d):I.get_locking_script();let $=new e(BigInt(1),x);h.add_output($);const B=s.from_string(u).get_locking_script();let k=new e(BigInt(1),B);const v=Math.ceil(l*(h.get_size()+k.to_bytes().byteLength));let b=new e(BigInt(_.satoshis-v),B);h.add_output(b);const O=h.sign(m,i.InputOutput,0,t.from_asm_string(c.script),BigInt(c.satoshis));w.set_unlocking_script(t.from_asm_string(`${O.to_hex()} ${m.to_public_key().to_hex()}`)),h.set_input(0,w);const T=h.sign(g,i.InputOutput,1,t.from_asm_string(_.script),BigInt(_.satoshis));return y.set_unlocking_script(t.from_asm_string(`${T.to_hex()} ${g.to_public_key().to_hex()}`)),h.set_input(1,y),h},p=async(s,_,c,g)=>{const a=new n(1,0);let u=0;for(let t of s||[])u+=t.satoshis;const l=u-g;console.log({feeSats:g,satsIn:u,satsOut:l}),a.add_output(new e(BigInt(l),c.get_locking_script()));let m=0;for(let n of s||[]){console.log({u:n});const s=new o(r.from(n.txid,"hex"),n.vout,t.from_asm_string(""));console.log({inx:s}),s.set_satoshis(BigInt(n.satoshis)),a.add_input(s);const e=a.sign(_,i.InputOutputs,m,t.from_asm_string(n.script),BigInt(n.satoshis));s.set_unlocking_script(t.from_asm_string(`${e.to_hex()} ${_.to_public_key().to_hex()}`)),a.set_input(m,s),m++}return a};export{a as buildInscription,l as createOrdinal,u as reinscribeOrdinalTemplate,m as sendOrdinal,p as sendUtxos};
//# sourceMappingURL=index.modern.js.map
