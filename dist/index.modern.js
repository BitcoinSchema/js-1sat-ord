import{P2PKH as t,LockingScript as o,Utils as n,fromUtxo as s,SatoshisPerKilobyte as e,Transaction as i}from"@bsv/sdk";import{Sigma as r}from"sigma-protocol";const a=t=>Buffer.from(t).toString("hex"),d=10;class c extends t{lock(n,s,e,i){let r="";if(void 0!==s&&void 0!==e){const t=a("ord"),o=Buffer.from(s,"base64").toString("hex").trim();if(!o)throw new Error("Invalid file data");const n=a(e);if(!n)throw new Error("Invalid media type");r=`OP_0 OP_IF ${t} OP_1 ${n} OP_0 ${o} OP_ENDIF`}let d=`${r?`${r} `:""}${(new t).lock(n).toASM()}`;if(i&&(!i.app||!i.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=i&&i.app&&null!=i&&i.type){d=`${d} OP_RETURN ${a("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${a("SET")}`;for(const[t,o]of Object.entries(i))"cmd"!==t&&(d=`${d} ${a(t)} ${a(o)}`)}return o.fromASM(d)}}function u(){return u=Object.assign?Object.assign.bind():function(t){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var s in n)({}).hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},u.apply(null,arguments)}const{fromBase58Check:p}=n,l=(t,o)=>{const n=s(u({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),o);return n.sourceTXID=t.txid,n},f=async o=>{const n=`https://ordinals.gorillapool.io/api/txos/address/${o}/unspent?bsv20=false`;console.log({payUrl:n});const s=await fetch(n);if(!s.ok)throw new Error("Error fetching pay utxos");let e=await s.json();e=e.filter(t=>1!==t.satoshis);const i=p(o),r=(new t).lock(i.data);return e=e.map(t=>({txid:t.txid,vout:t.vout,satoshis:t.satoshis,script:Buffer.from(r.toBinary()).toString("base64")})),e},h=async(t,o)=>{const n=null==o?void 0:o.idKey,s=null==o?void 0:o.keyHost;if(n){const o=new r(t),{signedTx:s}=o.sign(n);return s}if(s){const n=null==o?void 0:o.authToken,e=new r(t);try{const{signedTx:t}=await e.remoteSign(s,n);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${s} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},g=async o=>{const{utxos:n,destinations:s,paymentPk:r,changeAddress:a,satsPerKb:u=d,metaData:p,signer:f,additionalPayments:g=[]}=o,m=new e(u);let w=new i;for(const o of n){const n=l(o,(new t).unlock(r));w.addInput(n)}s.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of s){if(!t.inscription)throw new Error("Inscription is required for all destinations");w.addOutput({satoshis:1,lockingScript:(new c).lock(t.address,t.inscription.dataB64,t.inscription.contentType,p)})}for(const o of g)w.addOutput({satoshis:o.amount,lockingScript:(new t).lock(o.to)});const k=n.reduce((t,o)=>t+BigInt(o.satoshis),0n),x=w.outputs.reduce((t,o)=>t+BigInt(o.satoshis||0),0n),y=await m.computeFee(w);let S;if(k>x+BigInt(y)){const o=(new t).lock(a||r.toAddress().toString()),n={lockingScript:o,change:!0};S={txid:"",vout:w.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},w.addOutput(n)}return f&&(w=await h(w,f)),await w.fee(m),await w.sign(),S&&(S.satoshis=w.outputs[w.outputs.length-1].satoshis,S.txid=w.hash("hex")),{tx:w,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:S}},m=async o=>{o.satsPerKb||(o.satsPerKb=d),o.additionalPayments||(o.additionalPayments=[]),void 0===o.enforceUniformSend&&(o.enforceUniformSend=!0);const n=new e(o.satsPerKb);let s=new i;const r=[];for(const t of o.ordinals){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=l(t,(new c).unlock(o.ordPk));r.push(`${t.txid}_${t.vout}`),s.addInput(n)}if(o.enforceUniformSend&&o.destinations.length!==o.ordinals.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of o.destinations){var a,u;let e;e=null!=(a=n.inscription)&&a.dataB64&&null!=(u=n.inscription)&&u.contentType?(new c).lock(n.address,n.inscription.dataB64,n.inscription.contentType,o.metaData):(new t).lock(n.address),s.addOutput({satoshis:1,lockingScript:e})}for(const n of o.additionalPayments)console.log("Additional payment",n),s.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});for(const n of o.paymentUtxos){const e=l(n,(new t).unlock(o.paymentPk));r.push(`${n.txid}_${n.vout}`),s.addInput(e)}const p=await n.computeFee(s),f=o.paymentUtxos.reduce((t,o)=>t+BigInt(o.satoshis),0n),g=s.outputs.reduce((t,o)=>t+(o.satoshis||0),0);if(f<g)throw new Error("Not enough ordinals to send");let m;if(f>g+p){const n=(new t).lock(o.changeAddress||o.paymentPk.toAddress().toString()),e={lockingScript:n,change:!0};m={txid:"",vout:s.outputs.length,satoshis:0,script:Buffer.from(n.toHex(),"hex").toString("base64")},s.addOutput(e)}return o.signer&&(s=await h(s,o.signer)),await s.fee(n),await s.sign(),m&&(m.satoshis=s.outputs[s.outputs.length-1].satoshis,m.txid=s.hash("hex")),{tx:s,spentOutpoints:r,payChange:m}},w=async o=>{const{utxos:n,paymentPk:s,payments:r,satsPerKb:a=d,changeAddress:c=s.toAddress().toString()}=o,u=new e(a),p=new i;for(const o of r){const n={satoshis:o.amount,lockingScript:(new t).lock(o.to)};p.addOutput(n)}let f=0n;const h=p.outputs.reduce((t,o)=>t+(o.satoshis||0),0);let g,m=0;for(const o of n){const n=l(o,(new t).unlock(s));if(p.addInput(n),f+=BigInt(o.satoshis),m=await u.computeFee(p),f>=h+m)break}if(f<h+m)throw new Error(`Not enough funds to send. Total sats in: ${f}, Total sats out: ${h}, Fee: ${m}`);if(f>h+m){const o=(new t).lock(c),n={lockingScript:o,change:!0};g={txid:"",vout:p.outputs.length,satoshis:0,script:Buffer.from(o.toHex(),"hex").toString("base64")},p.addOutput(n)}else f<h+m&&console.log("No change needed");return await p.fee(u),await p.sign(),g&&(g.satoshis=p.outputs[p.outputs.length-1].satoshis,g.txid=p.hash("hex")),{tx:p,spentOutpoints:n.map(t=>`${t.txid}_${t.vout}`),payChange:g}};var k;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(k||(k={}));const x=async t=>{const{protocol:o,tokenID:n,utxos:s,inputTokens:e,distributions:i,paymentPk:r,ordPk:a,changeAddress:c,tokenChangeAddress:p,satsPerKb:l=d,metaData:f,signer:h,additionalPayments:g=[]}=t;let w=0n,x=0n,y=0n;if(!e.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of e)x+=BigInt(t.amt);for(const t of i)y+=BigInt(t.amt);if(x<y)throw new Error("Not enough tokens to send");if(w=x-y,w>0n){const t={address:p||a.toAddress().toString(),amt:w.toString()};i.push(t)}const S=i.map(t=>{const s={p:"bsv-20",op:"transfer",amt:t.amt};let e;if(o===k.BSV20)e=u({},s,{tick:n});else{if(o!==k.BSV21)throw new Error("Invalid protocol");e=u({},s,{id:n})}return{address:t.address,inscription:{dataB64:Buffer.from(JSON.stringify(e)).toString("base64"),contentType:"application/bsv-20"}}}),v={paymentUtxos:s,ordinals:e,paymentPk:r,ordPk:a,destinations:S,changeAddress:c||r.toAddress().toString(),satsPerKb:l,metaData:f,signer:h,additionalPayments:g,enforceUniformSend:!1},{tx:b,spentOutpoints:P,payChange:B}=await m(v),O=S.findIndex(t=>t.address===(p||a.toAddress().toString()));let $;return-1!==O&&($={id:n,amt:w.toString(),satoshis:1,txid:b.id("hex"),vout:O,script:Buffer.from(b.outputs[O].lockingScript.toHex(),"hex").toString("base64")}),{tx:b,spentOutpoints:P,payChange:B,tokenChange:$}};export{k as TokenType,g as createOrdinals,f as fetchPayUtxos,m as sendOrdinals,w as sendUtxos,x as transferOrdTokens};
//# sourceMappingURL=index.modern.js.map
