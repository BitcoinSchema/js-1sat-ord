import{P2PKH as n,LockingScript as t,SatoshisPerKilobyte as o,Transaction as i,fromUtxo as s}from"@bsv/sdk";import{Sigma as e}from"sigma-protocol";function r(){return r=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var o=arguments[t];for(var i in o)({}).hasOwnProperty.call(o,i)&&(n[i]=o[i])}return n},r.apply(null,arguments)}const c=n=>{const t=[];for(let o=0,i=n.length;o<i;o++){const i=Number(n.charCodeAt(o)).toString(16);t.push(i)}return t.join("")};class a extends n{lock(o,i,s,e){let r="";if(void 0!==i&&void 0!==s){const n=c("ord"),t=Buffer.from(i,"base64").toString("hex").trim();r=`OP_0 OP_IF ${n} OP_1 ${c(s)} OP_0 ${t?`${t} `:""}OP_ENDIF`}let a=`${r?`${r} `:""}${(new n).lock(o).toASM()}`;if(null!=e&&e.app&&null!=e&&e.type){a=`${a} OP_RETURN ${c("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${c("SET")}`;for(const[n,t]of Object.entries(e))"cmd"!==n&&(a=`${a} ${c(n)} ${c(t)}`)}return t.fromASM(a)}}const l=async(t,s,r,c,l,d,u,p=[])=>{const w=new o(l||10);let g=new i;for(const o of t){const t=f(o,(new n).unlock(r));g.addInput(t)}s.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const n of s){if(!n.inscription)throw new Error("Inscription is required for all destinations");g.addOutput({satoshis:1,lockingScript:(new a).lock(n.address,n.inscription.dataB64,n.inscription.contentType,d)})}for(const t of p)g.addOutput({satoshis:t.amount,lockingScript:(new n).lock(t.to)});g.addOutput({lockingScript:(new n).lock(c),change:!0});const k=null==u?void 0:u.idKey,h=null==u?void 0:u.keyHost;if(k){const n=new e(g),{signedTx:t}=n.sign(k);g=t}else if(h){const n=null==u?void 0:u.authToken,t=new e(g);try{const{signedTx:o}=await t.remoteSign(h,n);g=o}catch(n){throw console.log(n),new Error(`Remote signing to ${h} failed`)}}return await g.fee(w),await g.sign(),g},d=async(t,s,e,r,c,l,d,u,w=[])=>{const g=new o(d||p),k=new i;for(const n of s){const t=f(n,(new a).unlock(c));k.addInput(t)}for(const o of t){const t=f(o,(new n).unlock(e));k.addInput(t)}if(l.length!==s.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const t of l){var h,m;let o;o=null!=(h=t.inscription)&&h.dataB64&&null!=(m=t.inscription)&&m.contentType?(new a).lock(t.address,t.inscription.dataB64,t.inscription.contentType,u):(new n).lock(t.address),k.addOutput({satoshis:1,lockingScript:o})}for(const t of w)k.addOutput({satoshis:t.amount,lockingScript:(new n).lock(t.to)});const O=(new n).lock(r);return k.addOutput({lockingScript:O,change:!0}),await k.fee(g),await k.sign(),k},u=async(t,s,e,r,c)=>{const a=new o(c||p),l=new i;for(const o of t){const t=f(o,(new n).unlock(s));l.addInput(t)}const d={satoshis:r,lockingScript:(new n).lock(e)};l.addOutput(d);const u=s.toAddress().toString(),w=(new n).lock(u);return l.addOutput({lockingScript:w,change:!0}),await l.fee(a),await l.sign(),l},p=10,f=(n,t)=>s(r({},n,{script:Buffer.from(n.script,"base64").toString("hex")}),t);export{l as createOrdinals,d as sendOrdinals,u as sendUtxos};
//# sourceMappingURL=index.modern.js.map
