import{P2PKH as t,LockingScript as n,fromUtxo as o,SatoshisPerKilobyte as e,Transaction as r}from"@bsv/sdk";import{Sigma as s}from"sigma-protocol";const i=t=>Buffer.from(t).toString("hex");class a extends t{lock(o,e,r,s){let a="";if(void 0!==e&&void 0!==r){const t=i("ord"),n=Buffer.from(e,"base64").toString("hex").trim();if(!n)throw new Error("Invalid file data");const o=i(r);if(!o)throw new Error("Invalid media type");a=`OP_0 OP_IF ${t} OP_1 ${o} OP_0 ${n} OP_ENDIF`}let c=`${a?`${a} `:""}${(new t).lock(o).toASM()}`;if(s&&(!s.app||!s.type))throw new Error("MAP.app and MAP.type are required fields");if(null!=s&&s.app&&null!=s&&s.type){c=`${c} OP_RETURN ${i("1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5")} ${i("SET")}`;for(const[t,n]of Object.entries(s))"cmd"!==t&&(c=`${c} ${i(t)} ${i(n)}`)}return n.fromASM(c)}}function c(){return c=Object.assign?Object.assign.bind():function(t){for(var n=1;n<arguments.length;n++){var o=arguments[n];for(var e in o)({}).hasOwnProperty.call(o,e)&&(t[e]=o[e])}return t},c.apply(null,arguments)}const d=(t,n)=>{const e=o(c({},t,{script:Buffer.from(t.script,"base64").toString("hex")}),n);return e.sourceTXID=t.txid,e},l=async(t,n)=>{const o=null==n?void 0:n.idKey,e=null==n?void 0:n.keyHost;if(o){const n=new s(t),{signedTx:e}=n.sign(o);return e}if(e){const o=null==n?void 0:n.authToken,r=new s(t);try{const{signedTx:t}=await r.remoteSign(e,o);return t}catch(t){throw console.log(t),new Error(`Remote signing to ${e} failed`)}}throw new Error("Signer must be a LocalSigner or RemoteSigner")},u=async(n,o,s,i,c=10,u,f,p=[])=>{const w=new e(c);let g=new r;for(const o of n){const n=d(o,(new t).unlock(s));g.addInput(n)}o.length>100&&console.warn("Creating many inscriptions at once can be slow. Consider using multiple transactions instead.");for(const t of o){if(!t.inscription)throw new Error("Inscription is required for all destinations");g.addOutput({satoshis:1,lockingScript:(new a).lock(t.address,t.inscription.dataB64,t.inscription.contentType,u)})}for(const n of p)g.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});return g.addOutput({lockingScript:(new t).lock(i||s.toAddress().toString()),change:!0}),f&&(g=await l(g,f)),await g.fee(w),await g.sign(),g},f=async(n,o,s,i,c,u,f=10,p,w,g=[],h=!0)=>{const m=new e(f);let k=new r;for(const t of o){if(1!==t.satoshis)throw new Error("1Sat Ordinal utxos must have exactly 1 satoshi");const n=d(t,(new a).unlock(i));k.addInput(n)}if(h&&c.length!==o.length)throw new Error("Number of destinations must match number of ordinals being sent");for(const n of c){var S,y;let o;o=null!=(S=n.inscription)&&S.dataB64&&null!=(y=n.inscription)&&y.contentType?(new a).lock(n.address,n.inscription.dataB64,n.inscription.contentType,p):(new t).lock(n.address),k.addOutput({satoshis:1,lockingScript:o})}for(const n of g)console.log("Additional payment",n),k.addOutput({satoshis:n.amount,lockingScript:(new t).lock(n.to)});for(const o of n){const n=d(o,(new t).unlock(s));k.addInput(n)}const v=(new t).lock(u||s.toAddress().toString());return k.addOutput({lockingScript:v,change:!0}),w&&(k=await l(k,w)),await k.fee(m),await k.sign(),k},p=async(n,o,s,i=10)=>{const a=new e(i),c=new r;for(const n of s){const o={satoshis:n.amount,lockingScript:(new t).lock(n.to)};c.addOutput(o)}let l=0n;const u=c.outputs.reduce((t,n)=>t+(n.satoshis||0),0);let f=0;for(const e of n){const n=d(e,(new t).unlock(o));if(c.addInput(n),l+=BigInt(e.satoshis),f=await a.computeFee(c),l>=u+f)break}if(l<u+f)throw new Error(`Not enough funds to deploy token. Total sats in: ${l}, Total sats out: ${u}, Fee: ${f}`);if(l>u+f){const n=o.toAddress().toString(),e=(new t).lock(n);c.addOutput({lockingScript:e,change:!0})}else l<u+f&&console.log("No change needed");return await c.fee(a),await c.sign(),c};var w;!function(t){t.BSV20="bsv20",t.BSV21="bsv21"}(w||(w={}));const g=async(t,n,o,e,r,s,i,a,d,l=10,u,p,g=[])=>{let h=0n,m=0n,k=0n;if(!e.every(t=>t.id===n))throw new Error("Input tokens do not match the provided tokenID");for(const t of e)m+=BigInt(t.amt);for(const t of r)k+=BigInt(t.amt);if(m<k)throw new Error("Not enough tokens to send");if(h=m-k,h>0n){const t={address:d||i.toAddress().toString(),amt:h.toString()};r.push(t)}const S=r.map(o=>{const e={p:"bsv-20",op:"transfer",amt:o.amt};let r;if(t===w.BSV20)r=c({},e,{tick:n});else{if(t!==w.BSV21)throw new Error("Invalid protocol");r=c({},e,{id:n})}return{address:o.address,inscription:{dataB64:Buffer.from(JSON.stringify(r)).toString("base64"),contentType:"application/bsv-20"}}});return await f(o,e,s,i,S,a||s.toAddress().toString(),l,u,p,g,!1)};export{u as createOrdinals,f as sendOrdinals,p as sendUtxos,g as transferOrdTokens};
//# sourceMappingURL=index.modern.js.map
