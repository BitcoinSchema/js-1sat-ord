{"version":3,"file":"index.cjs","sources":["../src/utils/strings.ts","../src/index.ts"],"sourcesContent":["const toHex = (asciiStr: string) => {\r\n  var arr1: string[] = [];\r\n  for (var n = 0, l = asciiStr.length; n < l; n++) {\r\n    var hex = Number(asciiStr.charCodeAt(n)).toString(16);\r\n    arr1.push(hex);\r\n  }\r\n  return arr1.join(\"\");\r\n};\r\n\r\nconst toAscii = (hexStr: string) => {\r\n  var hex, i;\r\n\r\n  var result = \"\";\r\n  for (i = 0; i < hexStr.length; i++) {\r\n    hex = hexStr.charCodeAt(i).toString(16);\r\n    result += (\"000\" + hex).slice(-4);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport { toHex, toAscii };\r\n","import {\r\n  P2PKHAddress,\r\n  PrivateKey,\r\n  Script,\r\n  SigHash,\r\n  Transaction,\r\n  TxIn,\r\n  TxOut,\r\n} from \"bsv-wasm\";\r\nimport { Buffer } from \"buffer\";\r\nimport * as dotenv from \"dotenv\";\r\nimport { AuthToken, Sigma } from \"sigma-protocol\";\r\nimport { toHex } from \"./utils/strings\";\r\n\r\ndotenv.config();\r\n\r\ntype Signer = {};\r\n\r\nexport interface LocalSigner extends Signer {\r\n  idKey: PrivateKey;\r\n}\r\n\r\nexport interface RemoteSigner extends Signer {\r\n  keyHost: string;\r\n  authToken?: AuthToken;\r\n}\r\n\r\nexport type Utxo = {\r\n  satoshis: number;\r\n  txid: string;\r\n  vout: number;\r\n  script: string;\r\n};\r\n\r\nexport type Inscription = {\r\n  dataB64: string;\r\n  contentType: string;\r\n};\r\n\r\nexport type MAP = {\r\n  app: string;\r\n  type: string;\r\n  [prop: string]: string | string[];\r\n};\r\n\r\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\r\n\r\nconst buildInscription = (\r\n  destinationAddress: P2PKHAddress,\r\n  b64File?: string | undefined,\r\n  mediaType?: string | undefined,\r\n  metaData?: MAP | undefined\r\n): Script => {\r\n  let ordAsm = \"\";\r\n  // This can be omitted for reinscriptions that just update metadata\r\n  if (b64File !== undefined && mediaType !== undefined) {\r\n    const ordHex = toHex(\"ord\");\r\n    const fsBuffer = Buffer.from(b64File, \"base64\");\r\n    const fireShardHex = fsBuffer.toString(\"hex\");\r\n    const fireShardMediaType = toHex(mediaType);\r\n    ordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fireShardMediaType} OP_0 ${fireShardHex} OP_ENDIF`;\r\n  }\r\n\r\n  // Create ordinal output and inscription in a single output\r\n  let inscriptionAsm = `${destinationAddress\r\n    .get_locking_script()\r\n    .to_asm_string()}${ordAsm ? \" \" + ordAsm : \"\"}`;\r\n\r\n  // MAP.app and MAP.type keys are required\r\n  if (metaData && metaData?.app && metaData?.type) {\r\n    const mapPrefixHex = toHex(MAP_PREFIX);\r\n    const mapCmdValue = toHex(\"SET\");\r\n    inscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\r\n\r\n    for (const [key, value] of Object.entries(metaData)) {\r\n      if (key !== \"cmd\") {\r\n        inscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\r\n          value as string\r\n        )}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  return Script.from_asm_string(inscriptionAsm);\r\n};\r\n\r\nexport const reinscribeOrdinalTemplate = async (\r\n  ordinal: Utxo,\r\n  destinationAddress: string,\r\n  reinscription?: Inscription,\r\n  metaData?: MAP\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(ordinal.txid, \"hex\"),\r\n    ordinal.vout,\r\n    Script.from_asm_string(ordinal.script)\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  // Outputs\r\n  const inscriptionScript = buildInscription(\r\n    P2PKHAddress.from_string(destinationAddress),\r\n    reinscription?.dataB64,\r\n    reinscription?.contentType,\r\n    metaData\r\n  );\r\n\r\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\r\n  tx.add_output(satOut);\r\n\r\n  return tx;\r\n};\r\n\r\nconst createOrdinal = async (\r\n  utxo: Utxo,\r\n  destinationAddress: string,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  inscription: Inscription,\r\n  metaData?: MAP,\r\n  signer?: LocalSigner | RemoteSigner\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(utxo.txid, \"hex\"),\r\n    utxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  // Outputs\r\n  const inscriptionScript = buildInscription(\r\n    P2PKHAddress.from_string(destinationAddress),\r\n    inscription.dataB64,\r\n    inscription.contentType,\r\n    metaData\r\n  );\r\n\r\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = utxo.satoshis - 1 - fee;\r\n  if (change < 0) throw new Error(\"Inadequate satoshis for fee\");\r\n  if (change > 0) {\r\n    let changeOut = new TxOut(BigInt(change), changeScript);\r\n    tx.add_output(changeOut);\r\n  }\r\n\r\n  // sign tx if idKey or remote signer like starfish/tokenpass\r\n  const idKey = (signer as LocalSigner)?.idKey;\r\n  const keyHost = (signer as RemoteSigner)?.keyHost;\r\n  if (idKey) {\r\n    // input txids are available so sigma signature\r\n    // can be final before signing the tx\r\n    const sigma = new Sigma(tx);\r\n    const { signedTx } = sigma.sign(idKey);\r\n    tx = signedTx;\r\n  } else if (keyHost) {\r\n    const authToken = (signer as RemoteSigner)?.authToken;\r\n    const sigma = new Sigma(tx);\r\n    try {\r\n      const { signedTx } = await sigma.remoteSign(keyHost, authToken);\r\n      tx = signedTx;\r\n    } catch (e) {\r\n      console.log(e);\r\n      throw new Error(\"Remote signing to \" + keyHost + \" failed\");\r\n    }\r\n  }\r\n\r\n  const sig = tx.sign(\r\n    paymentPk,\r\n    SigHash.ALL | SigHash.FORKID,\r\n    0,\r\n    Script.from_asm_string(utxo.script),\r\n    BigInt(utxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(0, utxoIn);\r\n\r\n  return tx;\r\n};\r\n\r\nconst sendOrdinal = async (\r\n  paymentUtxo: Utxo,\r\n  ordinal: Utxo,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  ordPk: PrivateKey,\r\n  ordDestinationAddress: string,\r\n  reinscription?: Inscription,\r\n  metaData?: MAP\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  let ordIn = new TxIn(\r\n    Buffer.from(ordinal.txid, \"hex\"),\r\n    ordinal.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n  tx.add_input(ordIn);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(paymentUtxo.txid, \"hex\"),\r\n    paymentUtxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  let s: Script;\r\n  const destinationAddress = P2PKHAddress.from_string(ordDestinationAddress);\r\n  if (reinscription?.dataB64 && reinscription?.contentType) {\r\n    s = buildInscription(\r\n      destinationAddress,\r\n      reinscription.dataB64,\r\n      reinscription.contentType,\r\n      metaData\r\n    );\r\n  } else {\r\n    s = destinationAddress.get_locking_script();\r\n  }\r\n  let satOut = new TxOut(BigInt(1), s);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = paymentUtxo.satoshis - fee;\r\n  let changeOut = new TxOut(BigInt(change), changeScript);\r\n\r\n  tx.add_output(changeOut);\r\n\r\n  // sign ordinal\r\n  const sig = tx.sign(\r\n    ordPk,\r\n    SigHash.InputOutput,\r\n    0,\r\n    Script.from_asm_string(ordinal.script),\r\n    BigInt(ordinal.satoshis)\r\n  );\r\n\r\n  ordIn.set_unlocking_script(\r\n    Script.from_asm_string(`${sig.to_hex()} ${ordPk.to_public_key().to_hex()}`)\r\n  );\r\n\r\n  tx.set_input(0, ordIn);\r\n\r\n  // sign fee payment\r\n  const sig2 = tx.sign(\r\n    paymentPk,\r\n    SigHash.InputOutput,\r\n    1,\r\n    Script.from_asm_string(paymentUtxo.script),\r\n    BigInt(paymentUtxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig2.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(1, utxoIn);\r\n\r\n  return tx;\r\n};\r\n\r\n// sendUtxos sends p2pkh utxos to the given destinationAddress\r\nconst sendUtxos = async (\r\n  utxos: Utxo[],\r\n  paymentPk: PrivateKey,\r\n  address: P2PKHAddress,\r\n  feeSats: number\r\n): Promise<Transaction> => {\r\n  const tx = new Transaction(1, 0);\r\n\r\n  // Outputs\r\n  let inputValue = 0;\r\n  for (let u of utxos || []) {\r\n    inputValue += u.satoshis;\r\n  }\r\n  const satsIn = inputValue;\r\n  const satsOut = satsIn - feeSats;\r\n  console.log({ feeSats, satsIn, satsOut });\r\n  tx.add_output(new TxOut(BigInt(satsOut), address.get_locking_script()));\r\n\r\n  // build txins from our UTXOs\r\n  let idx = 0;\r\n  for (let u of utxos || []) {\r\n    console.log({ u });\r\n    const inx = new TxIn(\r\n      Buffer.from(u.txid, \"hex\"),\r\n      u.vout,\r\n      Script.from_asm_string(\"\")\r\n    );\r\n    console.log({ inx });\r\n    inx.set_satoshis(BigInt(u.satoshis));\r\n    tx.add_input(inx);\r\n\r\n    const sig = tx.sign(\r\n      paymentPk,\r\n      SigHash.InputOutputs,\r\n      idx,\r\n      Script.from_asm_string(u.script),\r\n      BigInt(u.satoshis)\r\n    );\r\n\r\n    inx.set_unlocking_script(\r\n      Script.from_asm_string(\r\n        `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n      )\r\n    );\r\n\r\n    tx.set_input(idx, inx);\r\n    idx++;\r\n  }\r\n  return tx;\r\n};\r\n\r\nexport { buildInscription, createOrdinal, sendOrdinal, sendUtxos };\r\n"],"names":["toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","toString","push","join","config","buildInscription","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fireShardHex","Buffer","from","fireShardMediaType","inscriptionAsm","get_locking_script","to_asm_string","app","type","mapCmdValue","_i","_Object$entries","Object","entries","_Object$entries$_i","key","value","Script","from_asm_string","utxo","paymentPk","changeAddress","satPerByteFee","inscription","signer","_temp2","_result3","sig","tx","sign","SigHash","ALL","FORKID","script","BigInt","satoshis","utxoIn","set_unlocking_script","to_hex","to_public_key","set_input","Transaction","TxIn","txid","vout","add_input","inscriptionScript","P2PKHAddress","from_string","dataB64","contentType","satOut","TxOut","add_output","changeScript","emptyOut","fee","Math","ceil","get_size","to_bytes","byteLength","change","Error","changeOut","idKey","keyHost","_temp","authToken","sigma","Sigma","Promise","resolve","remoteSign","then","_ref","signedTx","_catch","e","console","log","_sigma$sign","reject","ordinal","reinscription","paymentUtxo","ordPk","ordDestinationAddress","ordIn","s","InputOutput","sig2","utxos","address","feeSats","_step","inputValue","_iterator","_createForOfIteratorHelperLoose","done","satsOut","satsIn","_step2","idx","_iterator2","u","inx","set_satoshis","InputOutputs"],"mappings":"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"}