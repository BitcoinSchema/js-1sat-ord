{"version":3,"file":"index.cjs","sources":["../src/utils/strings.ts","../src/ordP2pkh.ts","../src/index.ts"],"sourcesContent":["const toHex = (asciiStr: string) => {\n  const arr1: string[] = [];\n  for (let n = 0, l = asciiStr.length; n < l; n++) {\n    const hex = Number(asciiStr.charCodeAt(n)).toString(16);\n    arr1.push(hex);\n  }\n  return arr1.join(\"\");\n};\n\nconst toAscii = (hexStr: string) => {\n  let hex: string;\n  let i: number;\n\n  let result = \"\";\n  for (i = 0; i < hexStr.length; i++) {\n    hex = hexStr.charCodeAt(i).toString(16);\n    result += (`000${hex}`).slice(-4);\n  }\n\n  return result;\n};\n\nexport { toHex, toAscii };\n","import {\n\tLockingScript,\n\tOP,\n\tP2PKH,\n\tPrivateKey,\n\ttype Script,\n\tTransaction,\n\tTransactionSignature,\n\tUnlockingScript,\n\ttype ScriptTemplate,\n} from \"@bsv/sdk\";\nimport { fromBase58Check } from \"@bsv/sdk/dist/types/src/primitives/utils\";\nimport type { MAP } from \".\";\nimport { toHex } from \"./utils/strings\";\n\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\n/**\n * OrdP2PKH (1Sat Ordinal + Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create an Ordinal with Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class OrdP2PKH extends P2PKH {\n\t/**\n\t * Creates a P2PKH locking script for a given public key hash or address string\n\t *\n\t * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.\n\t * @returns {LockingScript} - A P2PKH locking script.\n\t */\n\t// unlock method inherits from p2pkh\n\tlock(\n\t\tdestinationAddress: string,\n\t\tb64File?: string | undefined,\n\t\tmediaType?: string | undefined,\n\t\tmetaData?: MAP | undefined,\n\t): Script {\n\t\tlet ordAsm = \"\";\n\t\t// This can be omitted for reinscriptions that just update metadata\n\t\tif (b64File !== undefined && mediaType !== undefined) {\n\t\t\tconst ordHex = toHex(\"ord\");\n\t\t\tconst fsBuffer = Buffer.from(b64File, \"base64\");\n\t\t\tconst fileHex = fsBuffer.toString(\"hex\").trim();\n\t\t\tconst fileMediaType = toHex(mediaType);\n\t\t\tordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fileMediaType} OP_0 ${fileHex ? `${fileHex} ` : \"\"}OP_ENDIF`;\n\t\t}\n\n\t\t// Create ordinal output and inscription in a single output\n\t\tconst lockingScript = new P2PKH().lock(destinationAddress);\n\t\tlet inscriptionAsm = `${ordAsm ? `${ordAsm} ` : \"\"}${lockingScript.toASM()}`;\n\n\t\t// MAP.app and MAP.type keys are required\n\t\tif (metaData?.app && metaData?.type) {\n\t\t\tconst mapPrefixHex = toHex(MAP_PREFIX);\n\t\t\tconst mapCmdValue = toHex(\"SET\");\n\t\t\tinscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\n\n\t\t\tfor (const [key, value] of Object.entries(metaData)) {\n\t\t\t\tif (key !== \"cmd\") {\n\t\t\t\t\tinscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\n\t\t\t\t\t\tvalue as string,\n\t\t\t\t\t)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn LockingScript.fromASM(inscriptionAsm);\n\t}\n}\n","import {\n\ttype PrivateKey,\n\ttype Script,\n\tTransaction,\n\ttype UnlockingScript,\n\tP2PKH,\n\tSatoshisPerKilobyte,\n\tfromUtxo,\n\ttype TransactionOutput,\n} from \"@bsv/sdk\";\nimport { type AuthToken, Sigma } from \"sigma-protocol\";\nimport OrdP2PKH from \"./ordP2pkh\";\n\n// biome-ignore lint/complexity/noBannedTypes: Reserved for future use\ntype Signer = {};\n\nexport interface LocalSigner extends Signer {\n\tidKey: PrivateKey;\n}\n\nexport interface RemoteSigner extends Signer {\n\tkeyHost: string;\n\tauthToken?: AuthToken;\n}\n\nexport type Destination = {\n\taddress: string;\n\tinscription?: Inscription;\n};\n\n/**\n * @typedef {Object} Utxo\n * @property {number} satoshis - Amount in satoshis\n * @property {string} txid - Transaction id\n * @property {number} vout - Output index\n * @property {string} script - Base64 encoded locking script\n */\nexport type Utxo = {\n\tsatoshis: number;\n\ttxid: string;\n\tvout: number;\n\tscript: string;\n};\n\nexport type Inscription = {\n\tdataB64: string;\n\tcontentType: string;\n};\n\nexport type MAP = {\n\tapp: string;\n\ttype: string;\n\t[prop: string]: string | string[];\n};\n\nexport type Payment = {\n\tto: string;\n\tamount: number;\n};\n\nconst createOrdinals = async (\n\tutxos: Utxo[],\n\tdestinations: Destination[],\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tsatsPerKb?: number,\n\tmetaData?: MAP,\n\tsigner?: LocalSigner | RemoteSigner,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || 10);\n\tlet tx = new Transaction();\n\n\t// Inputs\n\tfor (const utxo of utxos) {\n\t\tconst input = fromB64Utxo(utxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Warn if creating many inscriptions at once\n\tif (destinations.length > 100) {\n\t\tconsole.warn(\n\t\t\t\"Creating many inscriptions at once can be slow. Consider using multiple transactions instead.\",\n\t\t);\n\t}\n\n\t// Outputs\n\t// Add inscription outputs\n\tfor (const destination of destinations) {\n\t\tif (!destination.inscription) {\n\t\t\tthrow new Error(\"Inscription is required for all destinations\");\n\t\t}\n\n\t\ttx.addOutput({\n\t\t\tsatoshis: 1,\n\t\t\tlockingScript: new OrdP2PKH().lock(\n\t\t\t\tdestination.address,\n\t\t\t\tdestination.inscription.dataB64,\n\t\t\t\tdestination.inscription.contentType,\n\t\t\t\tmetaData,\n\t\t\t),\n\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\ttx.addOutput({\n\t\t\tsatoshis: p.amount,\n\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t});\n\t}\n\n\t// Add change output\n\ttx.addOutput({\n\t\tlockingScript: new P2PKH().lock(changeAddress),\n\t\tchange: true,\n\t});\n\n\t// Sign tx if idKey or remote signer like starfish/tokenpass\n\tconst idKey = (signer as LocalSigner)?.idKey;\n\tconst keyHost = (signer as RemoteSigner)?.keyHost;\n\n\tif (idKey) {\n\t\tconst sigma = new Sigma(tx);\n\t\tconst { signedTx } = sigma.sign(idKey);\n\t\ttx = signedTx;\n\t} else if (keyHost) {\n\t\tconst authToken = (signer as RemoteSigner)?.authToken;\n\t\tconst sigma = new Sigma(tx);\n\t\ttry {\n\t\t\tconst { signedTx } = await sigma.remoteSign(keyHost, authToken);\n\t\t\ttx = signedTx;\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t\tthrow new Error(`Remote signing to ${keyHost} failed`);\n\t\t}\n\t}\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};\n\nconst sendOrdinals = async (\n\tpaymentUtxos: Utxo[],\n\tordinals: Utxo[],\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tordPk: PrivateKey,\n\tdestinations: Destination[],\n\tsatsPerKb?: number,\n\tmetaData?: MAP,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || DEFAULT_SAT_PER_KB);\n\tconst tx = new Transaction();\n\n\t// Inputs\n\t// Add ordinal inputs\n\tfor (const ordUtxo of ordinals) {\n\t\tconst input = fromB64Utxo(ordUtxo, new OrdP2PKH().unlock(ordPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Add payment inputs\n\tfor (const paymentUtxo of paymentUtxos) {\n\t\tconst input = fromB64Utxo(paymentUtxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Outputs\n\t// check that ordinals coming in matches ordinals going out if supplied\n\tif (destinations.length !== ordinals.length) {\n\t\tthrow new Error(\n\t\t\t\"Number of destinations must match number of ordinals being sent\",\n\t\t);\n\t}\n\n\t// Add ordinal outputs\n\tfor (const destination of destinations) {\n\t\tlet s: Script;\n\t\tif (\n\t\t\tdestination.inscription?.dataB64 &&\n\t\t\tdestination.inscription?.contentType\n\t\t) {\n\t\t\ts = new OrdP2PKH().lock(\n\t\t\t\tdestination.address,\n\t\t\t\tdestination.inscription.dataB64,\n\t\t\t\tdestination.inscription.contentType,\n\t\t\t\tmetaData,\n\t\t\t);\n\t\t} else {\n\t\t\ts = new P2PKH().lock(destination.address);\n\t\t}\n\n\t\ttx.addOutput({\n\t\t\tsatoshis: 1,\n\t\t\tlockingScript: s,\n\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\ttx.addOutput({\n\t\t\tsatoshis: p.amount,\n\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t});\n\t}\n\n\t// Add change output\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\tconst changeOut: TransactionOutput = {\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t};\n\ttx.addOutput(changeOut);\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};\n\n// sendUtxos sends p2pkh utxos to the given destinationAddress\nconst sendUtxos = async (\n\tutxos: Utxo[],\n\tpaymentPk: PrivateKey,\n\tdestinationAddress: string,\n\tamount: number,\n\tsatsPerKb?: number,\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || DEFAULT_SAT_PER_KB);\n\n\tconst tx = new Transaction();\n\n\t// Inputs\n\tfor (const utxo of utxos) {\n\t\tconst input = fromB64Utxo(utxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Outputs\n\tconst sendTxOut: TransactionOutput = {\n\t\tsatoshis: amount,\n\t\tlockingScript: new P2PKH().lock(destinationAddress),\n\t};\n\n\ttx.addOutput(sendTxOut);\n\n\t// Change\n\tconst changeAddress = paymentPk.toAddress().toString();\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\n\tconst changeOut: TransactionOutput = {\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t};\n\n\ttx.addOutput(changeOut);\n\n\t// Calculate fee\n\tawait tx.fee(modelOrFee);\n\n\t// Sign the transaction\n\tawait tx.sign();\n\n\treturn tx;\n};\n\nexport { createOrdinals, sendOrdinals, sendUtxos };\n\nconst DEFAULT_SAT_PER_KB = 10;\n\nconst fromB64Utxo = (\n\tutxo: Utxo,\n\tunlockScriptTemplate: {\n\t\tsign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n\t\testimateLength: (tx: Transaction, inputIndex: number) => Promise<number>;\n\t},\n) => {\n\treturn fromUtxo(\n\t\t{\n\t\t\t...utxo,\n\t\t\tscript: Buffer.from(utxo.script, \"base64\").toString(\"hex\"),\n\t\t},\n\t\tunlockScriptTemplate,\n\t);\n};\n"],"names":["toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","toString","push","join","OrdP2PKH","_P2PKH","apply","arguments","prototype","lock","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fileHex","Buffer","from","trim","fileMediaType","inscriptionAsm","P2PKH","toASM","app","type","_i","_Object$entries","Object","entries","_Object$entries$_i","key","value","LockingScript","fromASM","fromB64Utxo","utxo","unlockScriptTemplate","fromUtxo","_extends","script","utxos","destinations","paymentPk","changeAddress","satsPerKb","signer","additionalPayments","_step","_temp2","_result3","Promise","resolve","tx","fee","modelOrFee","then","sign","SatoshisPerKilobyte","Transaction","_iterator","_createForOfIteratorHelperLoose","done","input","unlock","addInput","console","warn","_iterator2","_step2","destination","inscription","Error","addOutput","satoshis","lockingScript","address","dataB64","contentType","_step3","_iterator3","p","amount","to","change","idKey","keyHost","_temp","authToken","sigma","Sigma","remoteSign","_ref","signedTx","_catch","e","log","_sigma$sign","reject","paymentUtxos","ordinals","ordPk","_step4","_iterator4","_step5","_iterator5","_iterator6","_step6","_destination$inscript","_destination$inscript2","s","_step7","_iterator7","changeScript","_step8","_iterator8","sendTxOut","toAddress"],"mappings":"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"}