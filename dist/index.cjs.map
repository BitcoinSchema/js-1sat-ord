{"version":3,"file":"index.cjs","sources":["../node_modules/dotenv/lib/main.js","../src/utils/strings.ts","../src/index.ts"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  const vaultPath = _vaultPath(options)\n\n  // Parse .env.vault\n  const result = DotenvModule.configDotenv({ path: vaultPath })\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][INFO] ${message}`)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  _log('Loading env from encrypted .env.vault')\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n","const toHex = (asciiStr: string) => {\n  var arr1: string[] = [];\n  for (var n = 0, l = asciiStr.length; n < l; n++) {\n    var hex = Number(asciiStr.charCodeAt(n)).toString(16);\n    arr1.push(hex);\n  }\n  return arr1.join(\"\");\n};\n\nconst toAscii = (hexStr: string) => {\n  var hex, i;\n\n  var result = \"\";\n  for (i = 0; i < hexStr.length; i++) {\n    hex = hexStr.charCodeAt(i).toString(16);\n    result += (\"000\" + hex).slice(-4);\n  }\n\n  return result;\n};\n\nexport { toHex, toAscii };\n","import {\n\ttype PrivateKey,\n\ttype Script,\n\tTransaction,\n\tUnlockingScript,\n\tP2PKH,\n\tLockingScript,\n} from \"@bsv/sdk\";\nimport type { TransactionInput, TransactionOutput } from \"@bsv/sdk\";\nimport * as dotenv from \"dotenv\";\nimport { type AuthToken, Sigma } from \"sigma-protocol\";\nimport { toHex } from \"./utils/strings\";\n\ndotenv.config();\n\n// biome-ignore lint/complexity/noBannedTypes: <explanation>\ntype Signer = {};\n\nexport interface LocalSigner extends Signer {\n\tidKey: PrivateKey;\n}\n\nexport interface RemoteSigner extends Signer {\n\tkeyHost: string;\n\tauthToken?: AuthToken;\n}\n\nexport type Utxo = {\n\tsatoshis: number;\n\ttxid: string;\n\tvout: number;\n\tscript: string;\n};\n\nexport type Inscription = {\n\tdataB64: string;\n\tcontentType: string;\n};\n\nexport type MAP = {\n\tapp: string;\n\ttype: string;\n\t[prop: string]: string | string[];\n};\n\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst buildInscription = (\n\tdestinationAddress: string,\n\tb64File?: string | undefined,\n\tmediaType?: string | undefined,\n\tmetaData?: MAP | undefined,\n): Script => {\n\tlet ordAsm = \"\";\n\t// This can be omitted for reinscriptions that just update metadata\n\tif (b64File !== undefined && mediaType !== undefined) {\n\t\tconst ordHex = toHex(\"ord\");\n\t\tconst fsBuffer = Buffer.from(b64File, \"base64\");\n\t\tconst fireShardHex = fsBuffer.toString(\"hex\").trim();\n\t\tconst fireShardMediaType = toHex(mediaType);\n\t\tordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fireShardMediaType} OP_0 ${fireShardHex ? `${fireShardHex} `: ''}OP_ENDIF`;\n\t}\n\n\t// Create ordinal output and inscription in a single output\n\tconst lockingScript = new P2PKH().lock(destinationAddress);\n\tlet inscriptionAsm = `${lockingScript.toASM()}${ordAsm ? ` ${ordAsm}` : \"\"}`;\n\n\t// MAP.app and MAP.type keys are required\n\tif (metaData?.app && metaData?.type) {\n\t\tconst mapPrefixHex = toHex(MAP_PREFIX);\n\t\tconst mapCmdValue = toHex(\"SET\");\n\t\tinscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\n\n\t\tfor (const [key, value] of Object.entries(metaData)) {\n\t\t\tif (key !== \"cmd\") {\n\t\t\t\tinscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\n\t\t\t\t\tvalue as string,\n\t\t\t\t)}`;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn LockingScript.fromASM(inscriptionAsm);\n};\n\nexport const buildReinscriptionTemplate = async (\n\tordinal: Utxo,\n\tdestinationAddress: string,\n\treinscription?: Inscription,\n\tmetaData?: MAP,\n): Promise<Transaction> => {\n\t// Inputs\n\tconst txIn: TransactionInput = {\n\t\tsourceTXID: ordinal.txid,\n\t\tsourceOutputIndex: ordinal.vout,\n\t\tunlockingScript: UnlockingScript.fromASM(ordinal.script),\n\t\tsequence: 0,\n\t};\n\n\t// Outputs\n\tconst inscriptionScript = buildInscription(\n\t\tdestinationAddress,\n\t\treinscription?.dataB64,\n\t\treinscription?.contentType,\n\t\tmetaData,\n\t);\n\n\tconst txOut: TransactionOutput = {\n\t\tsatoshis: 1,\n\t\tlockingScript: inscriptionScript,\n\t};\n\n\treturn new Transaction(1, [txIn], [txOut], 0);\n};\n\nexport type Payment = {\n\tto: string;\n\tamount: number;\n};\n\nconst createOrdinal = async (\n\tutxo: Utxo,\n\tdestinationAddress: string,\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tsatPerByteFee: number,\n\tinscription: Inscription,\n\tmetaData?: MAP,\n\tsigner?: LocalSigner | RemoteSigner,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\tconst p2pkh = new P2PKH();\n\n\t// Inputs\n\tconst utxoIn: TransactionInput = {\n\t\tsourceTXID: utxo.txid,\n\t\tsourceOutputIndex: utxo.vout,\n\t\tunlockingScriptTemplate: p2pkh.unlock(paymentPk),\n\t\tsequence: 0xffffffff,\n\t};\n\n\t// Outputs\n\tconst inscriptionScript = buildInscription(\n\t\tdestinationAddress,\n\t\tinscription.dataB64,\n\t\tinscription.contentType,\n\t\tmetaData,\n\t);\n\n\tconst txOuts: TransactionOutput[] = [];\n\n\ttxOuts.push({\n\t\tsatoshis: 1,\n\t\tlockingScript: inscriptionScript,\n\t});\n\n\t// add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\ttxOuts.push({\n\t\t\tsatoshis: p.amount,\n\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t} as TransactionOutput);\n\t}\n\n\t// total the outputs\n\tlet totalOut = 0;\n\n\tfor (const txOut of txOuts) {\n\t\ttotalOut += txOut.satoshis || 0;\n\t}\n\n\t// add change\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\n\ttxOuts.push({\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t} as TransactionOutput);\n\n\tconst tx = new Transaction(1, [utxoIn], txOuts, 0);\n\tawait tx.fee();\n\tconst fee = tx.getFee() + P2PKH_OUTPUT_SIZE + P2PKH_INPUT_SCRIPT_SIZE;\n\n\t// sign tx if idKey or remote signer like starfish/tokenpass\n\tconst idKey = (signer as LocalSigner)?.idKey;\n\tconst keyHost = (signer as RemoteSigner)?.keyHost;\n\n  // TODO: Update Sigma lib to use ts-sdk\n\tif (idKey) {\n\t  // input txids are available so sigma signature\n\t  // can be final before signing the tx\n\t  // const sigma = new Sigma(tx);\n\t  // const { signedTx } = sigma.sign(idKey);\n\t  // tx = signedTx;\n\t} else if (keyHost) {\n\t  const authToken = (signer as RemoteSigner)?.authToken;\n\t  // const sigma = new Sigma(tx);\n\t  // try {\n\t  //   const { signedTx } = await sigma.remoteSign(keyHost, authToken);\n\t  //   tx = signedTx;\n\t  // } catch (e) {\n\t  //   console.log(e);\n\t  //   throw new Error(`Remote signing to ${keyHost} failed`);\n\t  // }\n\t}\n\tawait tx.sign();\n\n\treturn tx;\n};\n\nconst sendOrdinal = async (\n\tpaymentUtxo: Utxo,\n\tordinal: Utxo,\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tsatPerByteFee: number,\n\tordPk: PrivateKey,\n\tordDestinationAddress: string,\n\treinscription?: Inscription,\n\tmetaData?: MAP,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\n\n\t// Inputs\n  const txIns: TransactionInput[] = [];\n  const ordIn: TransactionInput = {\n    sourceTXID: ordinal.txid,\n    sourceOutputIndex: ordinal.vout,\n    unlockingScript: UnlockingScript.fromASM(ordinal.script),\n    unlockingScriptTemplate: new P2PKH().unlock(ordPk),\n    sequence: 0xffffffff,\n  };\n  \n  txIns.push(ordIn);\n\n  const utxoIn: TransactionInput = {\n    sourceTXID: paymentUtxo.txid,\n    sourceOutputIndex: paymentUtxo.vout,\n    unlockingScriptTemplate: new P2PKH().unlock(paymentPk),\n    sequence: 0xffffffff,\n  };\n\n  txIns.push(utxoIn);\n\n  // Outputs\n\tlet s: Script;\n\t\n\tif (reinscription?.dataB64 && reinscription?.contentType) {\n\t\ts = buildInscription(\n\t\t\tordDestinationAddress,\n\t\t\treinscription.dataB64,\n\t\t\treinscription.contentType,\n\t\t\tmetaData,\n\t\t);\n\t} else {\n\t\ts = new P2PKH().lock(ordDestinationAddress);\n\t}\n\n  const txOuts: TransactionOutput[] = [];\n  txOuts.push({\n    satoshis: 1,\n    lockingScript: s,\n  });\n\n\t// add additional payments if any\n\tfor (const p of additionalPayments) {\n    txOuts.push({\n      satoshis: p.amount,\n      lockingScript: new P2PKH().lock(p.to),\n    });\n\t}\n\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\n  const changeOut: TransactionOutput = {\n    satoshis: paymentUtxo.satoshis - 1,\n    lockingScript: changeScript,\n    change: true,\n  };\n  txOuts.push(changeOut);\n\n  const tx = new Transaction(1, txIns, txOuts, 0);\n\n  await tx.fee();\n  await tx.sign();\n\n\treturn tx;\n};\n\n// sendUtxos sends p2pkh utxos to the given destinationAddress\nconst sendUtxos = async (\n\tutxos: Utxo[],\n\tpaymentPk: PrivateKey,\n\taddress: string,\n\tfeeSats: number,\n): Promise<Transaction> => {\n\t// const tx = new Transaction(1, 0);\n\n\t// // Outputs\n\t// let inputValue = 0;\n\t// for (let u of utxos || []) {\n\t// \tinputValue += u.satoshis;\n\t// }\n\t// const satsIn = inputValue;\n\t// const satsOut = satsIn - feeSats;\n\t// console.log({ feeSats, satsIn, satsOut });\n\t// tx.add_output(new TxOut(BigInt(satsOut), address.get_locking_script()));\n\n\t// // build txins from our UTXOs\n\t// let idx = 0;\n\t// for (let u of utxos || []) {\n\t// \tconsole.log({ u });\n\t// \tconst inx = new TxIn(\n\t// \t\tBuffer.from(u.txid, \"hex\"),\n\t// \t\tu.vout,\n\t// \t\tScript.from_asm_string(\"\"),\n\t// \t);\n\t// \tconsole.log({ inx });\n\t// \tinx.set_satoshis(BigInt(u.satoshis));\n\t// \ttx.add_input(inx);\n\n\t// \tconst sig = tx.sign(\n\t// \t\tpaymentPk,\n\t// \t\tSigHash.InputOutputs,\n\t// \t\tidx,\n\t// \t\tScript.from_asm_string(u.script),\n\t// \t\tBigInt(u.satoshis),\n\t// \t);\n\n\t// \tinx.set_unlocking_script(\n\t// \t\tScript.from_asm_string(\n\t// \t\t\t`${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`,\n\t// \t\t),\n\t// \t);\n\n\t// \ttx.set_input(idx, inx);\n\t// \tidx++;\n\t// }\n\treturn new Transaction(1, [], [], 0);\n};\n\nexport const P2PKH_INPUT_SCRIPT_SIZE = 107;\nexport const P2PKH_FULL_INPUT_SIZE = 148;\nexport const P2PKH_OUTPUT_SIZE = 34;\n\nexport { buildInscription, createOrdinal, sendOrdinal, sendUtxos };\n"],"names":["version","LINE","_debug","message","console","log","_dotenvKey","options","DOTENV_KEY","length","process","env","_instructions","result","dotenvKey","uri","URL","error","code","err","Error","key","password","environment","searchParams","get","environmentKey","toUpperCase","ciphertext","parsed","_vaultPath","possibleVaultPath","path","Array","isArray","filepath","fs","existsSync","endsWith","resolve","cwd","_resolveHome","envPath","join","os","homedir","slice","DotenvModule","configDotenv","dotenvPath","encoding","debug","Boolean","lastError","optionPaths","push","parsedAll","parse","readFileSync","populate","e","processEnv","_configVault","_parseVault","vaultPath","keys","split","decrypted","i","attrs","trim","decrypt","config","encrypted","keyStr","Buffer","from","nonce","subarray","authTag","aesgcm","crypto","createDecipheriv","setAuthTag","update","final","isRange","RangeError","decryptionFailed","src","obj","match","lines","toString","replace","exec","value","maybeQuote","override","Object","prototype","hasOwnProperty","call","_configVault_1","_parseVault_1","config_1","decrypt_1","parse_1","populate_1","main","toHex","asciiStr","arr1","n","l","hex","Number","charCodeAt","dotenv","buildInscription","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fireShardHex","inscriptionAsm","P2PKH","lock","toASM","app","type","mapCmdValue","_i","_Object$entries","entries","_Object$entries$_i","LockingScript","fromASM","ordinal","reinscription","txIn","sourceTXID","txid","sourceOutputIndex","vout","unlockingScript","UnlockingScript","script","sequence","inscriptionScript","dataB64","contentType","Promise","Transaction","satoshis","lockingScript","reject","utxo","paymentPk","changeAddress","satPerByteFee","inscription","signer","additionalPayments","p2pkh","utxoIn","unlockingScriptTemplate","unlock","txOuts","_iterator","_step","_createForOfIteratorHelperLoose","done","p","amount","to","_i2","_txOuts","changeScript","change","tx","fee","then","getFee","sign","paymentUtxo","ordPk","ordDestinationAddress","txIns","ordIn","s","_step2","_iterator2","utxos","address","feeSats"],"mappings":"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"}