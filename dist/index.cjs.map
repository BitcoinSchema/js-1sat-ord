{"version":3,"file":"index.cjs","sources":["../src/utils/strings.ts","../src/ordP2pkh.ts","../src/index.ts"],"sourcesContent":["const toHex = (asciiStr: string) => {\n  const arr1: string[] = [];\n  for (let n = 0, l = asciiStr.length; n < l; n++) {\n    const hex = Number(asciiStr.charCodeAt(n)).toString(16);\n    arr1.push(hex);\n  }\n  return arr1.join(\"\");\n};\n\nconst toAscii = (hexStr: string) => {\n  let hex: string;\n  let i: number;\n\n  let result = \"\";\n  for (i = 0; i < hexStr.length; i++) {\n    hex = hexStr.charCodeAt(i).toString(16);\n    result += (`000${hex}`).slice(-4);\n  }\n\n  return result;\n};\n\nexport { toHex, toAscii };\n","import {\n\tLockingScript,\n\tOP,\n\tP2PKH,\n\tPrivateKey,\n\ttype Script,\n\tTransaction,\n\tTransactionSignature,\n\tUnlockingScript,\n\ttype ScriptTemplate,\n} from \"@bsv/sdk\";\nimport { fromBase58Check } from \"@bsv/sdk/dist/types/src/primitives/utils\";\nimport type { MAP } from \".\";\nimport { toHex } from \"./utils/strings\";\n\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\n/**\n * OrdP2PKH (1Sat Ordinal + Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create an Ordinal with Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nexport default class OrdP2PKH extends P2PKH {\n\t/**\n\t * Creates a P2PKH locking script for a given public key hash or address string\n\t *\n\t * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.\n\t * @returns {LockingScript} - A P2PKH locking script.\n\t */\n\t// unlock method inherits from p2pkh\n\tlock(\n\t\tdestinationAddress: string,\n\t\tb64File?: string | undefined,\n\t\tmediaType?: string | undefined,\n\t\tmetaData?: MAP | undefined,\n\t): Script {\n\t\tlet ordAsm = \"\";\n\t\t// This can be omitted for reinscriptions that just update metadata\n\t\tif (b64File !== undefined && mediaType !== undefined) {\n\t\t\tconst ordHex = toHex(\"ord\");\n\t\t\tconst fsBuffer = Buffer.from(b64File, \"base64\");\n\t\t\tconst fileHex = fsBuffer.toString(\"hex\").trim();\n\t\t\tconst fileMediaType = toHex(mediaType);\n\t\t\tordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fileMediaType} OP_0 ${fileHex ? `${fileHex} ` : \"\"}OP_ENDIF`;\n\t\t}\n\n\t\t// Create ordinal output and inscription in a single output\n\t\tconst lockingScript = new P2PKH().lock(destinationAddress);\n\t\tlet inscriptionAsm = `${ordAsm ? `${ordAsm} ` : \"\"}${lockingScript.toASM()}`;\n\n\t\t// MAP.app and MAP.type keys are required\n\t\tif (metaData?.app && metaData?.type) {\n\t\t\tconst mapPrefixHex = toHex(MAP_PREFIX);\n\t\t\tconst mapCmdValue = toHex(\"SET\");\n\t\t\tinscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\n\n\t\t\tfor (const [key, value] of Object.entries(metaData)) {\n\t\t\t\tif (key !== \"cmd\") {\n\t\t\t\t\tinscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\n\t\t\t\t\t\tvalue as string,\n\t\t\t\t\t)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn LockingScript.fromASM(inscriptionAsm);\n\t}\n}\n","import {\n\ttype PrivateKey,\n\ttype Script,\n\tTransaction,\n\tUnlockingScript,\n\tP2PKH,\n\tLockingScript,\n\tSatoshisPerKilobyte,\n} from \"@bsv/sdk\";\nimport type { TransactionInput, TransactionOutput } from \"@bsv/sdk\";\nimport { type AuthToken, Sigma } from \"sigma-protocol\";\nimport type FeeModel from \"@bsv/sdk/dist/types/src/transaction/FeeModel\";\nimport OrdP2PKH from \"./ordP2pkh\";\n\n// biome-ignore lint/complexity/noBannedTypes: Reserved for future use\ntype Signer = {};\n\nexport interface LocalSigner extends Signer {\n\tidKey: PrivateKey;\n}\n\nexport interface RemoteSigner extends Signer {\n\tkeyHost: string;\n\tauthToken?: AuthToken;\n}\n\nexport type Utxo = {\n  rawTxHex: string;\n  vout: number;\n};\n\nexport type Inscription = {\n\tdataB64: string;\n\tcontentType: string;\n};\n\nexport type MAP = {\n\tapp: string;\n\ttype: string;\n\t[prop: string]: string | string[];\n};\n\nexport const buildReinscriptionTemplate = async (\n\tordinal: Utxo,\n\tdestinationAddress: string,\n\treinscription?: Inscription,\n\tmetaData?: MAP,\n): Promise<Transaction> => {\n\t// Inputs\n\tconst txIn: TransactionInput = {\n\t\tsourceTransaction: Transaction.fromHex(ordinal.rawTxHex),\n\t\tsourceOutputIndex: ordinal.vout,\n\t\tsequence: 0,\n\t};\n\n\t// Outputs\n\tconst inscriptionScript = new OrdP2PKH().lock(\n\t\tdestinationAddress,\n\t\treinscription?.dataB64,\n\t\treinscription?.contentType,\n\t\tmetaData,\n\t);\n\n\tconst txOut: TransactionOutput = {\n\t\tsatoshis: 1,\n\t\tlockingScript: inscriptionScript,\n\t};\n\n\treturn new Transaction(1, [txIn], [txOut], 0);\n};\n\nexport type Payment = {\n\tto: string;\n\tamount: number;\n};\n\nconst createOrdinal = async (\n\tutxos: Utxo[],\n\tdestinationAddress: string,\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tinscriptions: Inscription[],\n\tsatsPerKb?: number,\n\tmetaData?: MAP,\n\tsigner?: LocalSigner | RemoteSigner,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || 10);\n\t// Inputs\n\tconst txIns: TransactionInput[] = utxos.map(utxo => {\n\t\t\tconst sourceTx = Transaction.fromHex(utxo.rawTxHex);\n\t\t\treturn {\n\t\t\t\t\tsourceTransaction: sourceTx,\n\t\t\t\t\tsourceOutputIndex: utxo.vout,\n\t\t\t\t\tunlockingScriptTemplate: new P2PKH().unlock(paymentPk),\n\t\t\t\t\tsequence: 0xffffffff,\n\t\t\t};\n\t});\n\n\t// Warn if creating many inscriptions at once\n\tif (inscriptions.length > 100) {\n\t\t\tconsole.warn(\"Creating many inscriptions at once can be slow. Consider using multiple transactions instead.\");\n\t}\n\n\t// Outputs\n\tconst txOuts: TransactionOutput[] = [];\n\n\t// Add inscription outputs\n\tfor (const inscription of inscriptions) {\n\t\t\tconst inscriptionScript = new OrdP2PKH().lock(\n\t\t\t\t\tdestinationAddress,\n\t\t\t\t\tinscription.dataB64,\n\t\t\t\t\tinscription.contentType,\n\t\t\t\t\tmetaData,\n\t\t\t);\n\n\t\t\ttxOuts.push({\n\t\t\t\t\tsatoshis: 1,\n\t\t\t\t\tlockingScript: inscriptionScript,\n\t\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\t\ttxOuts.push({\n\t\t\t\t\tsatoshis: p.amount,\n\t\t\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t\t} as TransactionOutput);\n\t}\n\n\t// Add change output\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\ttxOuts.push({\n\t\t\tlockingScript: changeScript,\n\t\t\tchange: true,\n\t} as TransactionOutput);\n\n\tlet tx = new Transaction(1, txIns, txOuts, 0);\n\n\t// Sign tx if idKey or remote signer like starfish/tokenpass\n\tconst idKey = (signer as LocalSigner)?.idKey;\n\tconst keyHost = (signer as RemoteSigner)?.keyHost;\n\n\tif (idKey) {\n\t\t\tconst sigma = new Sigma(tx);\n\t\t\tconst { signedTx } = sigma.sign(idKey);\n\t\t\ttx = signedTx;\n\t} else if (keyHost) {\n\t\t\tconst authToken = (signer as RemoteSigner)?.authToken;\n\t\t\tconst sigma = new Sigma(tx);\n\t\t\ttry {\n\t\t\t\t\tconst { signedTx } = await sigma.remoteSign(keyHost, authToken);\n\t\t\t\t\ttx = signedTx;\n\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t\tthrow new Error(`Remote signing to ${keyHost} failed`);\n\t\t\t}\n\t}\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};\n\nconst transferOrdinal = async (\n\tpaymentUtxos: Utxo[],\n\tordinals: Utxo[],\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tordPk: PrivateKey,\n\tordDestinationAddress: string,\n\tsatsPerKb: number,\n\treinscription?: Inscription,\n\tmetaData?: MAP,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || 10);\n\n\t// Inputs\n\tconst txIns: TransactionInput[] = [];\n\n\t// Add ordinal inputs\n\tfor (const ordinal of ordinals) {\n\t\t\tconst ordinalTx = Transaction.fromHex(ordinal.rawTxHex);\n\t\t\tconst ordIn: TransactionInput = {\n\t\t\t\t\tsourceTransaction: ordinalTx,\n\t\t\t\t\tsourceOutputIndex: ordinal.vout,\n\t\t\t\t\tunlockingScriptTemplate: new OrdP2PKH().unlock(\n\t\t\t\t\t\t\tordPk,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tLockingScript.fromASM(ordinalTx.outputs[ordinal.vout].lockingScript.toASM())\n\t\t\t\t\t),\n\t\t\t\t\tsequence: 0xffffffff,\n\t\t\t};\n\t\t\ttxIns.push(ordIn);\n\t}\n\n\t// Add payment inputs\n\tfor (const paymentUtxo of paymentUtxos) {\n\t\t\tconst paymentTx = Transaction.fromHex(paymentUtxo.rawTxHex);\n\t\t\tconst utxoIn: TransactionInput = {\n\t\t\t\t\tsourceTransaction: paymentTx,\n\t\t\t\t\tsourceOutputIndex: paymentUtxo.vout,\n\t\t\t\t\tunlockingScriptTemplate: new P2PKH().unlock(paymentPk),\n\t\t\t\t\tsequence: 0xffffffff,\n\t\t\t};\n\t\t\ttxIns.push(utxoIn);\n\t}\n\n\t// Outputs\n\tconst txOuts: TransactionOutput[] = [];\n\n\t// Add ordinal outputs\n\tfor (const ordinal of ordinals) {\n\t\t\tlet s: Script;\n\t\t\tif (reinscription?.dataB64 && reinscription?.contentType) {\n\t\t\t\t\ts = new OrdP2PKH().lock(\n\t\t\t\t\t\t\tordDestinationAddress,\n\t\t\t\t\t\t\treinscription.dataB64,\n\t\t\t\t\t\t\treinscription.contentType,\n\t\t\t\t\t\t\tmetaData,\n\t\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t\ts = new P2PKH().lock(ordDestinationAddress);\n\t\t\t}\n\n\t\t\ttxOuts.push({\n\t\t\t\t\tsatoshis: 1,\n\t\t\t\t\tlockingScript: s,\n\t\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\t\ttxOuts.push({\n\t\t\t\t\tsatoshis: p.amount,\n\t\t\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t\t});\n\t}\n\n\t// Add change output\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\tconst changeOut: TransactionOutput = {\n\t\t\tlockingScript: changeScript,\n\t\t\tchange: true,\n\t};\n\ttxOuts.push(changeOut);\n\n\tconst tx = new Transaction(1, txIns, txOuts, 0);\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};\n\n// sendUtxos sends p2pkh utxos to the given destinationAddress\nconst sendUtxos = async (\n  utxos: Utxo[],\n  paymentPk: PrivateKey,\n  destinationAddress: string,\n  satsPerKb: number,\n\tamount: number,\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb || 10);\n\n  // Inputs\n  const txIns: TransactionInput[] = utxos.map(utxo => {\n      const sourceTx = Transaction.fromHex(utxo.rawTxHex);\n      \n      return {\n          sourceTransaction: sourceTx,\n          sourceOutputIndex: utxo.vout,\n          unlockingScriptTemplate: new P2PKH().unlock(paymentPk),\n          sequence: 0xffffffff,\n      };\n  });\n\n  // Outputs\n\tconst txOuts: TransactionOutput[] = [];\n\n  const sendTxOut: TransactionOutput = {\n      satoshis: amount,\n      lockingScript: new P2PKH().lock(destinationAddress),\n  };\n\n\ttxOuts.push(sendTxOut);\n\n\t// Change\n\tconst changeAddress = paymentPk.toAddress().toString();\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\n\tconst changeOut: TransactionOutput = {\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t};\n\n\ttxOuts.push(changeOut);\n\n  // Create transaction\n  const tx = new Transaction(1, txIns, txOuts, 0);\n\n  // Calculate fee\n  await tx.fee(modelOrFee);\n\n  // Sign the transaction\n  await tx.sign();\n\n  return tx;\n};\n\nexport { createOrdinal, transferOrdinal, sendUtxos };\n"],"names":["toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","toString","push","join","OrdP2PKH","_P2PKH","apply","arguments","prototype","lock","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fileHex","Buffer","from","trim","fileMediaType","inscriptionAsm","P2PKH","toASM","app","type","_i","_Object$entries","Object","entries","_Object$entries$_i","key","value","LockingScript","fromASM","ordinal","reinscription","txIn","sourceTransaction","Transaction","fromHex","rawTxHex","sourceOutputIndex","vout","sequence","inscriptionScript","dataB64","contentType","Promise","resolve","satoshis","lockingScript","e","reject","utxos","paymentPk","changeAddress","inscriptions","satsPerKb","signer","additionalPayments","_temp2","_result3","tx","fee","modelOrFee","then","sign","SatoshisPerKilobyte","txIns","map","utxo","unlockingScriptTemplate","unlock","console","warn","_step","txOuts","_iterator","_createForOfIteratorHelperLoose","done","inscription","_step2","_iterator2","p","amount","to","changeScript","change","idKey","keyHost","_temp","authToken","sigma","Sigma","remoteSign","_ref","signedTx","_catch","log","Error","_sigma$sign","sendTxOut","toAddress","paymentUtxos","ordinals","ordPk","ordDestinationAddress","_step3","_iterator3","ordinalTx","ordIn","outputs","_iterator4","_step4","paymentUtxo","utxoIn","_iterator5","s","_iterator6","_step6"],"mappings":"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"}