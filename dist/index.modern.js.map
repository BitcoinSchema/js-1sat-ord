{"version":3,"file":"index.modern.js","sources":["../src/utils/strings.ts","../src/index.ts"],"sourcesContent":["const toHex = (asciiStr: string) => {\r\n  var arr1: string[] = [];\r\n  for (var n = 0, l = asciiStr.length; n < l; n++) {\r\n    var hex = Number(asciiStr.charCodeAt(n)).toString(16);\r\n    arr1.push(hex);\r\n  }\r\n  return arr1.join(\"\");\r\n};\r\n\r\nconst toAscii = (hexStr: string) => {\r\n  var hex, i;\r\n\r\n  var result = \"\";\r\n  for (i = 0; i < hexStr.length; i++) {\r\n    hex = hexStr.charCodeAt(i).toString(16);\r\n    result += (\"000\" + hex).slice(-4);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport { toHex, toAscii };\r\n","import { MAP } from \"bmapjs/types/protocols/map\";\r\nimport {\r\n  P2PKHAddress,\r\n  PrivateKey,\r\n  Script,\r\n  SigHash,\r\n  Transaction,\r\n  TxIn,\r\n  TxOut,\r\n} from \"bsv-wasm\";\r\nimport { Buffer } from \"buffer\";\r\nimport * as dotenv from \"dotenv\";\r\nimport { Sigma } from \"sigma-protocol\";\r\nimport { toHex } from \"./utils/strings\";\r\n\r\ndotenv.config();\r\n\r\nexport type Utxo = {\r\n  satoshis: number;\r\n  txid: string;\r\n  vout: number;\r\n  script: string;\r\n};\r\n\r\nexport type Inscription = {\r\n  dataB64: string;\r\n  contentType: string;\r\n};\r\n\r\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\r\n\r\nconst buildInscription = (\r\n  destinationAddress: P2PKHAddress,\r\n  b64File: string,\r\n  mediaType: string,\r\n  metaData?: MAP\r\n): Script => {\r\n  const ordHex = toHex(\"ord\");\r\n  const fsBuffer = Buffer.from(b64File, \"base64\");\r\n  const fireShardHex = fsBuffer.toString(\"hex\");\r\n  const fireShardMediaType = toHex(mediaType);\r\n\r\n  // Create ordinal output and inscription in a single output\r\n  let inscriptionAsm = `${destinationAddress\r\n    .get_locking_script()\r\n    .to_asm_string()} OP_0 OP_IF ${ordHex} OP_1 ${fireShardMediaType} OP_0 ${fireShardHex} OP_ENDIF`;\r\n\r\n  // MAP.app and MAP.type keys are required\r\n  if (metaData && metaData?.app && metaData?.type) {\r\n    const mapPrefixHex = toHex(MAP_PREFIX);\r\n    const mapCmdValue = toHex(\"SET\");\r\n    inscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\r\n\r\n    for (const [key, value] of Object.entries(metaData)) {\r\n      if (key !== \"cmd\") {\r\n        inscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\r\n          value as string\r\n        )}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  return Script.from_asm_string(inscriptionAsm);\r\n};\r\n\r\nconst createOrdinal = async (\r\n  utxo: Utxo,\r\n  destinationAddress: string,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  inscription: Inscription,\r\n  metaData?: MAP,\r\n  idKey?: PrivateKey\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(utxo.txid, \"hex\"),\r\n    utxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  // Outputs\r\n  const inscriptionScript = buildInscription(\r\n    P2PKHAddress.from_string(destinationAddress),\r\n    inscription.dataB64,\r\n    inscription.contentType,\r\n    metaData\r\n  );\r\n\r\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = utxo.satoshis - 1 - fee;\r\n  if (change < 0) throw new Error(\"Inadequate satoshis for fee\");\r\n  if (change > 0) {\r\n    let changeOut = new TxOut(BigInt(change), changeScript);\r\n    tx.add_output(changeOut);\r\n  }\r\n  const sig = tx.sign(\r\n    paymentPk,\r\n    SigHash.ALL | SigHash.FORKID,\r\n    0,\r\n    Script.from_asm_string(utxo.script),\r\n    BigInt(utxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(0, utxoIn);\r\n\r\n  // sign tx if idKey is provided\r\n  if (idKey) {\r\n    const sigma = new Sigma(tx);\r\n    const { signedTx } = sigma.sign(idKey);\r\n    tx = signedTx;\r\n  }\r\n\r\n  return tx;\r\n};\r\n\r\nconst sendOrdinal = async (\r\n  paymentUtxo: Utxo,\r\n  ordinal: Utxo,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  ordPk: PrivateKey,\r\n  ordDestinationAddress: string,\r\n  reinscription?: Inscription,\r\n  metaData?: MAP\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  let ordIn = new TxIn(\r\n    Buffer.from(ordinal.txid, \"hex\"),\r\n    ordinal.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n  tx.add_input(ordIn);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(paymentUtxo.txid, \"hex\"),\r\n    paymentUtxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  let s: Script;\r\n  const destinationAddress = P2PKHAddress.from_string(ordDestinationAddress);\r\n  if (reinscription?.dataB64 && reinscription?.contentType) {\r\n    s = buildInscription(\r\n      destinationAddress,\r\n      reinscription.dataB64,\r\n      reinscription.contentType,\r\n      metaData\r\n    );\r\n  } else {\r\n    s = destinationAddress.get_locking_script();\r\n  }\r\n  let satOut = new TxOut(BigInt(1), s);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = paymentUtxo.satoshis - fee;\r\n  let changeOut = new TxOut(BigInt(change), changeScript);\r\n\r\n  tx.add_output(changeOut);\r\n\r\n  // sign ordinal\r\n  const sig = tx.sign(\r\n    ordPk,\r\n    SigHash.InputOutput,\r\n    0,\r\n    Script.from_asm_string(ordinal.script),\r\n    BigInt(ordinal.satoshis)\r\n  );\r\n\r\n  ordIn.set_unlocking_script(\r\n    Script.from_asm_string(`${sig.to_hex()} ${ordPk.to_public_key().to_hex()}`)\r\n  );\r\n\r\n  tx.set_input(0, ordIn);\r\n\r\n  // sign fee payment\r\n  const sig2 = tx.sign(\r\n    paymentPk,\r\n    SigHash.InputOutput,\r\n    1,\r\n    Script.from_asm_string(paymentUtxo.script),\r\n    BigInt(paymentUtxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig2.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(1, utxoIn);\r\n\r\n  return tx;\r\n};\r\n\r\n// sendUtxos sends p2pkh utxos to the given destinationAddress\r\nconst sendUtxos = async (\r\n  utxos: Utxo[],\r\n  paymentPk: PrivateKey,\r\n  address: P2PKHAddress,\r\n  feeSats: number\r\n): Promise<Transaction> => {\r\n  const tx = new Transaction(1, 0);\r\n\r\n  // Outputs\r\n  let inputValue = 0;\r\n  for (let u of utxos || []) {\r\n    inputValue += u.satoshis;\r\n  }\r\n  const satsIn = inputValue;\r\n  const satsOut = satsIn - feeSats;\r\n  console.log({ feeSats, satsIn, satsOut });\r\n  tx.add_output(new TxOut(BigInt(satsOut), address.get_locking_script()));\r\n\r\n  // build txins from our UTXOs\r\n  let idx = 0;\r\n  for (let u of utxos || []) {\r\n    console.log({ u });\r\n    const inx = new TxIn(\r\n      Buffer.from(u.txid, \"hex\"),\r\n      u.vout,\r\n      Script.from_asm_string(\"\")\r\n    );\r\n    console.log({ inx });\r\n    inx.set_satoshis(BigInt(u.satoshis));\r\n    tx.add_input(inx);\r\n\r\n    const sig = tx.sign(\r\n      paymentPk,\r\n      SigHash.InputOutputs,\r\n      idx,\r\n      Script.from_asm_string(u.script),\r\n      BigInt(u.satoshis)\r\n    );\r\n\r\n    inx.set_unlocking_script(\r\n      Script.from_asm_string(\r\n        `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n      )\r\n    );\r\n\r\n    tx.set_input(idx, inx);\r\n    idx++;\r\n  }\r\n  return tx;\r\n};\r\n\r\nexport { buildInscription, createOrdinal, sendOrdinal, sendUtxos };\r\n"],"names":["toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","toString","push","join","dotenv","config","buildInscription","destinationAddress","b64File","mediaType","metaData","ordHex","fireShardHex","Buffer","from","fireShardMediaType","inscriptionAsm","get_locking_script","to_asm_string","app","type","key","value","Object","entries","Script","from_asm_string","createOrdinal","async","utxo","paymentPk","changeAddress","satPerByteFee","inscription","idKey","tx","Transaction","utxoIn","TxIn","txid","vout","add_input","inscriptionScript","P2PKHAddress","from_string","dataB64","contentType","satOut","TxOut","BigInt","add_output","changeScript","emptyOut","fee","Math","ceil","get_size","to_bytes","byteLength","change","satoshis","Error","changeOut","sig","sign","SigHash","ALL","FORKID","script","set_unlocking_script","to_hex","to_public_key","set_input","sigma","Sigma","signedTx","sendOrdinal","paymentUtxo","ordinal","ordPk","ordDestinationAddress","reinscription","ordIn","s","InputOutput","sig2","sendUtxos","utxos","address","feeSats","inputValue","u","satsOut","console","log","satsIn","idx","inx","set_satoshis","InputOutputs"],"mappings":"uMAAA,MAAMA,EAASC,IAEb,IADA,IAAIC,EAAiB,GACZC,EAAI,EAAGC,EAAIH,EAASI,OAAQF,EAAIC,EAAGD,IAAK,CAC/C,IAAIG,EAAMC,OAAON,EAASO,WAAWL,IAAIM,SAAS,IAClDP,EAAKQ,KAAKJ,EACX,CACD,OAAOJ,EAAKS,KAAK,GAAE,ECSrBC,EAAOC,SAcP,MAEMC,EAAmBA,CACvBC,EACAC,EACAC,EACAC,KAEA,MAAMC,EAASnB,EAAM,OAEfoB,EADWC,EAAOC,KAAKN,EAAS,UACRP,SAAS,OACjCc,EAAqBvB,EAAMiB,GAGjC,IAAIO,EAAiB,GAAGT,EACrBU,qBACAC,8BAA8BP,UAAeI,UAA2BH,aAG3E,GAAIF,GAAYA,MAAAA,GAAAA,EAAUS,KAAe,MAART,GAAAA,EAAUU,KAAM,CAG/CJ,KAAoBA,eAFCxB,EApBN,yCAqBKA,EAAM,SAG1B,IAAK,MAAO6B,EAAKC,KAAUC,OAAOC,QAAQd,GAC5B,QAARW,IACFL,EAAiB,GAAGA,KAAkBxB,EAAM6B,MAAQ7B,EAClD8B,KAIP,CAED,OAAOG,EAAOC,gBAAgBV,EAAc,EAGxCW,EAAgBC,MACpBC,EACAtB,EACAuB,EACAC,EACAC,EACAC,EACAvB,EACAwB,KAEA,IAAIC,EAAK,IAAIC,EAAY,EAAG,GAGxBC,EAAS,IAAIC,EACfzB,EAAOC,KAAKe,EAAKU,KAAM,OACvBV,EAAKW,KACLf,EAAOC,gBAAgB,KAGzBS,EAAGM,UAAUJ,GAGb,MAAMK,EAAoBpC,EACxBqC,EAAaC,YAAYrC,GACzB0B,EAAYY,QACZZ,EAAYa,YACZpC,GAGF,IAAIqC,EAAS,IAAIC,EAAMC,OAAO,GAAIP,GAClCP,EAAGe,WAAWH,GAGd,MACMI,EADaR,EAAaC,YAAYb,GACZd,qBAChC,IAAImC,EAAW,IAAIJ,EAAMC,OAAO,GAAIE,GACpC,MAAME,EAAMC,KAAKC,KACfvB,GAAiBG,EAAGqB,WAAaJ,EAASK,WAAWC,aAEjDC,EAAS9B,EAAK+B,SAAW,EAAIP,EACnC,GAAIM,EAAS,EAAG,MAAM,IAAIE,MAAM,+BAChC,GAAIF,EAAS,EAAG,CACd,IAAIG,EAAY,IAAId,EAAMC,OAAOU,GAASR,GAC1ChB,EAAGe,WAAWY,EACf,CACD,MAAMC,EAAM5B,EAAG6B,KACblC,EACAmC,EAAQC,IAAMD,EAAQE,OACtB,EACA1C,EAAOC,gBAAgBG,EAAKuC,QAC5BnB,OAAOpB,EAAK+B,WAYd,GATAvB,EAAOgC,qBACL5C,EAAOC,gBACF,GAAAqC,EAAIO,YAAYxC,EAAUyC,gBAAgBD,aAIjDnC,EAAGqC,UAAU,EAAGnC,GAGZH,EAAO,CACT,MAAMuC,EAAQ,IAAIC,EAAMvC,IAClBwC,SAAEA,GAAaF,EAAMT,KAAK9B,GAChCC,EAAKwC,CACN,CAED,OAAOxC,GAGHyC,EAAchD,MAClBiD,EACAC,EACAhD,EACAC,EACAC,EACA+C,EACAC,EACAC,EACAvE,KAEA,IAAIyB,EAAK,IAAIC,EAAY,EAAG,GAExB8C,EAAQ,IAAI5C,EACdzB,EAAOC,KAAKgE,EAAQvC,KAAM,OAC1BuC,EAAQtC,KACRf,EAAOC,gBAAgB,KAEzBS,EAAGM,UAAUyC,GAGb,IAQIC,EARA9C,EAAS,IAAIC,EACfzB,EAAOC,KAAK+D,EAAYtC,KAAM,OAC9BsC,EAAYrC,KACZf,EAAOC,gBAAgB,KAGzBS,EAAGM,UAAUJ,GAGb,MAAM9B,EAAqBoC,EAAaC,YAAYoC,GAElDG,EADe,MAAbF,GAAAA,EAAepC,SAAWoC,MAAAA,GAAAA,EAAenC,YACvCxC,EACFC,EACA0E,EAAcpC,QACdoC,EAAcnC,YACdpC,GAGEH,EAAmBU,qBAEzB,IAAI8B,EAAS,IAAIC,EAAMC,OAAO,GAAIkC,GAClChD,EAAGe,WAAWH,GAGd,MACMI,EADaR,EAAaC,YAAYb,GACZd,qBAChC,IAAImC,EAAW,IAAIJ,EAAMC,OAAO,GAAIE,GACpC,MAAME,EAAMC,KAAKC,KACfvB,GAAiBG,EAAGqB,WAAaJ,EAASK,WAAWC,aAGvD,IAAII,EAAY,IAAId,EAAMC,OADX4B,EAAYjB,SAAWP,GACIF,GAE1ChB,EAAGe,WAAWY,GAGd,MAAMC,EAAM5B,EAAG6B,KACbe,EACAd,EAAQmB,YACR,EACA3D,EAAOC,gBAAgBoD,EAAQV,QAC/BnB,OAAO6B,EAAQlB,WAGjBsB,EAAMb,qBACJ5C,EAAOC,gBAAmB,GAAAqC,EAAIO,YAAYS,EAAMR,gBAAgBD,aAGlEnC,EAAGqC,UAAU,EAAGU,GAGhB,MAAMG,EAAOlD,EAAG6B,KACdlC,EACAmC,EAAQmB,YACR,EACA3D,EAAOC,gBAAgBmD,EAAYT,QACnCnB,OAAO4B,EAAYjB,WAWrB,OARAvB,EAAOgC,qBACL5C,EAAOC,gBACF,GAAA2D,EAAKf,YAAYxC,EAAUyC,gBAAgBD,aAIlDnC,EAAGqC,UAAU,EAAGnC,GAETF,GAIHmD,EAAY1D,MAChB2D,EACAzD,EACA0D,EACAC,KAEA,MAAMtD,EAAK,IAAIC,EAAY,EAAG,GAG9B,IAAIsD,EAAa,EACjB,IAAK,IAAIC,KAAKJ,GAAS,GACrBG,GAAcC,EAAE/B,SAElB,MACMgC,EADSF,EACUD,EACzBI,QAAQC,IAAI,CAAEL,UAASM,OAFRL,EAEgBE,YAC/BzD,EAAGe,WAAW,IAAIF,EAAMC,OAAO2C,GAAUJ,EAAQvE,uBAGjD,IAAI+E,EAAM,EACV,IAAK,IAAIL,KAAKJ,GAAS,GAAI,CACzBM,QAAQC,IAAI,CAAEH,MACd,MAAMM,EAAM,IAAI3D,EACdzB,EAAOC,KAAK6E,EAAEpD,KAAM,OACpBoD,EAAEnD,KACFf,EAAOC,gBAAgB,KAEzBmE,QAAQC,IAAI,CAAEG,QACdA,EAAIC,aAAajD,OAAO0C,EAAE/B,WAC1BzB,EAAGM,UAAUwD,GAEb,MAAMlC,EAAM5B,EAAG6B,KACblC,EACAmC,EAAQkC,aACRH,EACAvE,EAAOC,gBAAgBiE,EAAEvB,QACzBnB,OAAO0C,EAAE/B,WAGXqC,EAAI5B,qBACF5C,EAAOC,gBACF,GAAAqC,EAAIO,YAAYxC,EAAUyC,gBAAgBD,aAIjDnC,EAAGqC,UAAUwB,EAAKC,GAClBD,GACD,CACD,OAAO7D"}