{"version":3,"file":"index.modern.js","sources":["../node_modules/dotenv/lib/main.js","../src/utils/strings.ts","../src/index.ts"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n","const toHex = (asciiStr: string) => {\r\n  var arr1: string[] = [];\r\n  for (var n = 0, l = asciiStr.length; n < l; n++) {\r\n    var hex = Number(asciiStr.charCodeAt(n)).toString(16);\r\n    arr1.push(hex);\r\n  }\r\n  return arr1.join(\"\");\r\n};\r\n\r\nconst toAscii = (hexStr: string) => {\r\n  var hex, i;\r\n\r\n  var result = \"\";\r\n  for (i = 0; i < hexStr.length; i++) {\r\n    hex = hexStr.charCodeAt(i).toString(16);\r\n    result += (\"000\" + hex).slice(-4);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nexport { toHex, toAscii };\r\n","import {\r\n  P2PKHAddress,\r\n  PrivateKey,\r\n  Script,\r\n  SigHash,\r\n  Transaction,\r\n  TxIn,\r\n  TxOut,\r\n} from \"bsv-wasm\";\r\nimport { Buffer } from \"buffer\";\r\nimport * as dotenv from \"dotenv\";\r\nimport { AuthToken, Sigma } from \"sigma-protocol\";\r\nimport { toHex } from \"./utils/strings\";\r\n\r\ndotenv.config();\r\n\r\ntype Signer = {};\r\n\r\nexport interface LocalSigner extends Signer {\r\n  idKey: PrivateKey;\r\n}\r\n\r\nexport interface RemoteSigner extends Signer {\r\n  keyHost: string;\r\n  authToken?: AuthToken;\r\n}\r\n\r\nexport type Utxo = {\r\n  satoshis: number;\r\n  txid: string;\r\n  vout: number;\r\n  script: string;\r\n};\r\n\r\nexport type Inscription = {\r\n  dataB64: string;\r\n  contentType: string;\r\n};\r\n\r\nexport type MAP = {\r\n  app: string;\r\n  type: string;\r\n  [prop: string]: string | string[];\r\n};\r\n\r\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\r\n\r\nconst buildInscription = (\r\n  destinationAddress: P2PKHAddress,\r\n  b64File?: string | undefined,\r\n  mediaType?: string | undefined,\r\n  metaData?: MAP | undefined\r\n): Script => {\r\n  let ordAsm = \"\";\r\n  // This can be omitted for reinscriptions that just update metadata\r\n  if (b64File !== undefined && mediaType !== undefined) {\r\n    const ordHex = toHex(\"ord\");\r\n    const fsBuffer = Buffer.from(b64File, \"base64\");\r\n    const fireShardHex = fsBuffer.toString(\"hex\");\r\n    const fireShardMediaType = toHex(mediaType);\r\n    ordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fireShardMediaType} OP_0 ${fireShardHex} OP_ENDIF`;\r\n  }\r\n\r\n  // Create ordinal output and inscription in a single output\r\n  let inscriptionAsm = `${destinationAddress\r\n    .get_locking_script()\r\n    .to_asm_string()}${ordAsm ? \" \" + ordAsm : \"\"}`;\r\n\r\n  // MAP.app and MAP.type keys are required\r\n  if (metaData && metaData?.app && metaData?.type) {\r\n    const mapPrefixHex = toHex(MAP_PREFIX);\r\n    const mapCmdValue = toHex(\"SET\");\r\n    inscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\r\n\r\n    for (const [key, value] of Object.entries(metaData)) {\r\n      if (key !== \"cmd\") {\r\n        inscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\r\n          value as string\r\n        )}`;\r\n      }\r\n    }\r\n  }\r\n\r\n  return Script.from_asm_string(inscriptionAsm);\r\n};\r\n\r\nexport const buildReinscriptionTemplate = async (\r\n  ordinal: Utxo,\r\n  destinationAddress: string,\r\n  reinscription?: Inscription,\r\n  metaData?: MAP\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(ordinal.txid, \"hex\"),\r\n    ordinal.vout,\r\n    Script.from_asm_string(ordinal.script)\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  // Outputs\r\n  const inscriptionScript = buildInscription(\r\n    P2PKHAddress.from_string(destinationAddress),\r\n    reinscription?.dataB64,\r\n    reinscription?.contentType,\r\n    metaData\r\n  );\r\n\r\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\r\n  tx.add_output(satOut);\r\n\r\n  return tx;\r\n};\r\n\r\nconst createOrdinal = async (\r\n  utxo: Utxo,\r\n  destinationAddress: string,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  inscription: Inscription,\r\n  metaData?: MAP,\r\n  signer?: LocalSigner | RemoteSigner\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(utxo.txid, \"hex\"),\r\n    utxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  // Outputs\r\n  const inscriptionScript = buildInscription(\r\n    P2PKHAddress.from_string(destinationAddress),\r\n    inscription.dataB64,\r\n    inscription.contentType,\r\n    metaData\r\n  );\r\n\r\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = utxo.satoshis - 1 - fee;\r\n  if (change < 0) throw new Error(\"Inadequate satoshis for fee\");\r\n  if (change > 0) {\r\n    let changeOut = new TxOut(BigInt(change), changeScript);\r\n    tx.add_output(changeOut);\r\n  }\r\n\r\n  // sign tx if idKey or remote signer like starfish/tokenpass\r\n  const idKey = (signer as LocalSigner)?.idKey;\r\n  const keyHost = (signer as RemoteSigner)?.keyHost;\r\n  if (idKey) {\r\n    // input txids are available so sigma signature\r\n    // can be final before signing the tx\r\n    const sigma = new Sigma(tx);\r\n    const { signedTx } = sigma.sign(idKey);\r\n    tx = signedTx;\r\n  } else if (keyHost) {\r\n    const authToken = (signer as RemoteSigner)?.authToken;\r\n    const sigma = new Sigma(tx);\r\n    try {\r\n      const { signedTx } = await sigma.remoteSign(keyHost, authToken);\r\n      tx = signedTx;\r\n    } catch (e) {\r\n      console.log(e);\r\n      throw new Error(\"Remote signing to \" + keyHost + \" failed\");\r\n    }\r\n  }\r\n\r\n  const sig = tx.sign(\r\n    paymentPk,\r\n    SigHash.ALL | SigHash.FORKID,\r\n    0,\r\n    Script.from_asm_string(utxo.script),\r\n    BigInt(utxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(0, utxoIn);\r\n\r\n  return tx;\r\n};\r\n\r\nconst sendOrdinal = async (\r\n  paymentUtxo: Utxo,\r\n  ordinal: Utxo,\r\n  paymentPk: PrivateKey,\r\n  changeAddress: string,\r\n  satPerByteFee: number,\r\n  ordPk: PrivateKey,\r\n  ordDestinationAddress: string,\r\n  reinscription?: Inscription,\r\n  metaData?: MAP\r\n): Promise<Transaction> => {\r\n  let tx = new Transaction(1, 0);\r\n\r\n  let ordIn = new TxIn(\r\n    Buffer.from(ordinal.txid, \"hex\"),\r\n    ordinal.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n  tx.add_input(ordIn);\r\n\r\n  // Inputs\r\n  let utxoIn = new TxIn(\r\n    Buffer.from(paymentUtxo.txid, \"hex\"),\r\n    paymentUtxo.vout,\r\n    Script.from_asm_string(\"\")\r\n  );\r\n\r\n  tx.add_input(utxoIn);\r\n\r\n  let s: Script;\r\n  const destinationAddress = P2PKHAddress.from_string(ordDestinationAddress);\r\n  if (reinscription?.dataB64 && reinscription?.contentType) {\r\n    s = buildInscription(\r\n      destinationAddress,\r\n      reinscription.dataB64,\r\n      reinscription.contentType,\r\n      metaData\r\n    );\r\n  } else {\r\n    s = destinationAddress.get_locking_script();\r\n  }\r\n  let satOut = new TxOut(BigInt(1), s);\r\n  tx.add_output(satOut);\r\n\r\n  // add change\r\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\r\n  const changeScript = changeaddr.get_locking_script();\r\n  let emptyOut = new TxOut(BigInt(1), changeScript);\r\n  const fee = Math.ceil(\r\n    satPerByteFee * (tx.get_size() + emptyOut.to_bytes().byteLength)\r\n  );\r\n  const change = paymentUtxo.satoshis - fee;\r\n  let changeOut = new TxOut(BigInt(change), changeScript);\r\n\r\n  tx.add_output(changeOut);\r\n\r\n  // sign ordinal\r\n  const sig = tx.sign(\r\n    ordPk,\r\n    SigHash.InputOutput,\r\n    0,\r\n    Script.from_asm_string(ordinal.script),\r\n    BigInt(ordinal.satoshis)\r\n  );\r\n\r\n  ordIn.set_unlocking_script(\r\n    Script.from_asm_string(`${sig.to_hex()} ${ordPk.to_public_key().to_hex()}`)\r\n  );\r\n\r\n  tx.set_input(0, ordIn);\r\n\r\n  // sign fee payment\r\n  const sig2 = tx.sign(\r\n    paymentPk,\r\n    SigHash.InputOutput,\r\n    1,\r\n    Script.from_asm_string(paymentUtxo.script),\r\n    BigInt(paymentUtxo.satoshis)\r\n  );\r\n\r\n  utxoIn.set_unlocking_script(\r\n    Script.from_asm_string(\r\n      `${sig2.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n    )\r\n  );\r\n\r\n  tx.set_input(1, utxoIn);\r\n\r\n  return tx;\r\n};\r\n\r\n// sendUtxos sends p2pkh utxos to the given destinationAddress\r\nconst sendUtxos = async (\r\n  utxos: Utxo[],\r\n  paymentPk: PrivateKey,\r\n  address: P2PKHAddress,\r\n  feeSats: number\r\n): Promise<Transaction> => {\r\n  const tx = new Transaction(1, 0);\r\n\r\n  // Outputs\r\n  let inputValue = 0;\r\n  for (let u of utxos || []) {\r\n    inputValue += u.satoshis;\r\n  }\r\n  const satsIn = inputValue;\r\n  const satsOut = satsIn - feeSats;\r\n  console.log({ feeSats, satsIn, satsOut });\r\n  tx.add_output(new TxOut(BigInt(satsOut), address.get_locking_script()));\r\n\r\n  // build txins from our UTXOs\r\n  let idx = 0;\r\n  for (let u of utxos || []) {\r\n    console.log({ u });\r\n    const inx = new TxIn(\r\n      Buffer.from(u.txid, \"hex\"),\r\n      u.vout,\r\n      Script.from_asm_string(\"\")\r\n    );\r\n    console.log({ inx });\r\n    inx.set_satoshis(BigInt(u.satoshis));\r\n    tx.add_input(inx);\r\n\r\n    const sig = tx.sign(\r\n      paymentPk,\r\n      SigHash.InputOutputs,\r\n      idx,\r\n      Script.from_asm_string(u.script),\r\n      BigInt(u.satoshis)\r\n    );\r\n\r\n    inx.set_unlocking_script(\r\n      Script.from_asm_string(\r\n        `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\r\n      )\r\n    );\r\n\r\n    tx.set_input(idx, inx);\r\n    idx++;\r\n  }\r\n  return tx;\r\n};\r\n\r\nexport { buildInscription, createOrdinal, sendOrdinal, sendUtxos };\r\n"],"names":["LINE","_log","message","console","log","DotenvModule","config","options","dotenvPath","path","resolve","process","cwd","encoding","debug","Boolean","override","envPath","join","os","homedir","slice","parsed","parse","fs","readFileSync","Object","keys","forEach","key","prototype","hasOwnProperty","call","env","e","error","src","obj","match","lines","toString","replace","exec","value","trim","maybeQuote","config_1","parse_1","main","toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","push","dotenv","buildInscription","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fireShardHex","Buffer","from","inscriptionAsm","get_locking_script","to_asm_string","app","type","entries","Script","from_asm_string","buildReinscriptionTemplate","async","ordinal","reinscription","tx","Transaction","utxoIn","TxIn","txid","vout","script","add_input","inscriptionScript","P2PKHAddress","from_string","dataB64","contentType","satOut","TxOut","BigInt","add_output","createOrdinal","utxo","paymentPk","changeAddress","satPerByteFee","inscription","signer","changeScript","emptyOut","fee","Math","ceil","get_size","to_bytes","byteLength","change","satoshis","Error","changeOut","idKey","keyHost","sigma","Sigma","signedTx","sign","authToken","remoteSign","sig","SigHash","ALL","FORKID","set_unlocking_script","to_hex","to_public_key","set_input","sendOrdinal","paymentUtxo","ordPk","ordDestinationAddress","ordIn","s","InputOutput","sig2","sendUtxos","utxos","address","feeSats","inputValue","u","satsOut","satsIn","idx","inx","set_satoshis","InputOutputs"],"mappings":"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"}