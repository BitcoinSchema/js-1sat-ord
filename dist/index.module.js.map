{"version":3,"file":"index.module.js","sources":["../src/utils/strings.ts","../src/ordP2pkh.ts","../src/constants.ts","../src/utils/utxo.ts","../src/createOrdinals.ts","../src/sendOrdinals.ts","../src/sendUtxos.ts"],"sourcesContent":["const toHex = (asciiStr: string) => {\n  return Buffer.from(asciiStr).toString(\"hex\");\n};\n\nexport { toHex };\n","import {\n\tLockingScript,\n\tP2PKH,\n\ttype Script,\n} from \"@bsv/sdk\";\nimport type { MAP } from \"./types\";\nimport { toHex } from \"./utils/strings\";\nimport { MAP_PREFIX } from \"./constants\";\n\n/**\n * OrdP2PKH (1Sat Ordinal + Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create an Ordinal with Pay To Public Key Hash locking and unlocking scripts. \n * It extends the standard P2PKH script template and provides a custom lock method.\n */\nexport default class OrdP2PKH extends P2PKH {\n\t/**\n\t * Creates a 1Sat Ordinal + P2PKH locking script for a given address string\n\t *\n\t * @param {string} address - An destination address for the Ordinal.\n\t * @param {string} [b64File] - Base64 encoded file data.\n\t * @param {string} [mediaType] - Media type of the file.\n\t * @param {MAP} [metaData] - (optional) MAP Metadata to be included in OP_RETURN.\n\t * @returns {LockingScript} - A P2PKH locking script.\n\t */\n\t// unlock method inherits from p2pkh\n\tlock(\n\t\taddress: string,\n\t\tb64File?: string | undefined,\n\t\tmediaType?: string | undefined,\n\t\tmetaData?: MAP | undefined,\n\t): Script {\n\t\tlet ordAsm = \"\";\n\t\t// This can be omitted for reinscriptions that just update metadata\n\t\tif (b64File !== undefined && mediaType !== undefined) {\n\t\t\tconst ordHex = toHex(\"ord\");\n\t\t\tconst fsBuffer = Buffer.from(b64File, \"base64\");\n\t\t\tconst fileHex = fsBuffer.toString(\"hex\").trim();\n\t\t\tif (!fileHex) {\n\t\t\t\tthrow new Error(\"Invalid file data\");\n\t\t\t}\n\t\t\tconst fileMediaType = toHex(mediaType);\n\t\t\tif (!fileMediaType) {\n\t\t\t\tthrow new Error(\"Invalid media type\");\n\t\t\t}\n\t\t\tordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fileMediaType} OP_0 ${fileHex} OP_ENDIF`;\n\t\t}\n\n\t\t// Create ordinal output and inscription in a single output\n\t\tconst lockingScript = new P2PKH().lock(address);\n\t\tlet inscriptionAsm = `${ordAsm ? `${ordAsm} ` : \"\"}${lockingScript.toASM()}`;\n\n\t\t// MAP.app and MAP.type keys are required\n\t\tif (metaData && (!metaData.app || !metaData.type)) {\n\t\t\tthrow new Error(\"MAP.app and MAP.type are required fields\");\n\t\t}\n\n\t\tif (metaData?.app && metaData?.type) {\n\t\t\tconst mapPrefixHex = toHex(MAP_PREFIX);\n\t\t\tconst mapCmdValue = toHex(\"SET\");\n\t\t\tinscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\n\n\t\t\tfor (const [key, value] of Object.entries(metaData)) {\n\t\t\t\tif (key !== \"cmd\") {\n\t\t\t\t\tinscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\n\t\t\t\t\t\tvalue as string,\n\t\t\t\t\t)}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn LockingScript.fromASM(inscriptionAsm);\n\t}\n}\n","export const MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\nexport const DEFAULT_SAT_PER_KB = 10;","import { type Transaction, type UnlockingScript, fromUtxo } from \"@bsv/sdk\";\nimport type { Utxo } from \"../types\";\n\nexport const fromB64Utxo = (\n\tutxo: Utxo,\n\tunlockScriptTemplate: {\n\t\tsign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>;\n\t\testimateLength: (tx: Transaction, inputIndex: number) => Promise<number>;\n\t},\n) => {\n\tconst input = fromUtxo(\n\t\t{\n\t\t\t...utxo,\n\t\t\tscript: Buffer.from(utxo.script, \"base64\").toString(\"hex\"),\n\t\t},\n\t\tunlockScriptTemplate,\n\t);\n\tinput.sourceTXID = utxo.txid;\n\treturn input;\n};\n","import { type PrivateKey, Transaction, SatoshisPerKilobyte, P2PKH } from \"@bsv/sdk\";\nimport { Sigma } from \"sigma-protocol\";\nimport OrdP2PKH from \"./ordP2pkh\";\nimport type { Utxo, Destination, MAP, LocalSigner, RemoteSigner, Payment } from \"./types\";\nimport { fromB64Utxo } from \"./utils/utxo\";\nimport { DEFAULT_SAT_PER_KB } from \"./constants\";\n\nexport const createOrdinals = async (\n\tutxos: Utxo[],\n\tdestinations: Destination[],\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tsatsPerKb: number = DEFAULT_SAT_PER_KB,\n\tmetaData?: MAP,\n\tsigner?: LocalSigner | RemoteSigner,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb);\n\tlet tx = new Transaction();\n\n\t// Inputs\n\tfor (const utxo of utxos) {\n\t\tconst input = fromB64Utxo(utxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Warn if creating many inscriptions at once\n\tif (destinations.length > 100) {\n\t\tconsole.warn(\n\t\t\t\"Creating many inscriptions at once can be slow. Consider using multiple transactions instead.\",\n\t\t);\n\t}\n\n\t// Outputs\n\t// Add inscription outputs\n\tfor (const destination of destinations) {\n\t\tif (!destination.inscription) {\n\t\t\tthrow new Error(\"Inscription is required for all destinations\");\n\t\t}\n\n\t\ttx.addOutput({\n\t\t\tsatoshis: 1,\n\t\t\tlockingScript: new OrdP2PKH().lock(\n\t\t\t\tdestination.address,\n\t\t\t\tdestination.inscription.dataB64,\n\t\t\t\tdestination.inscription.contentType,\n\t\t\t\tmetaData,\n\t\t\t),\n\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\ttx.addOutput({\n\t\t\tsatoshis: p.amount,\n\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t});\n\t}\n\n\t// Add change output\n\ttx.addOutput({\n\t\tlockingScript: new P2PKH().lock(changeAddress),\n\t\tchange: true,\n\t});\n\n\t// Sign tx if idKey or remote signer like starfish/tokenpass\n\tconst idKey = (signer as LocalSigner)?.idKey;\n\tconst keyHost = (signer as RemoteSigner)?.keyHost;\n\n\tif (idKey) {\n\t\tconst sigma = new Sigma(tx);\n\t\tconst { signedTx } = sigma.sign(idKey);\n\t\ttx = signedTx;\n\t} else if (keyHost) {\n\t\tconst authToken = (signer as RemoteSigner)?.authToken;\n\t\tconst sigma = new Sigma(tx);\n\t\ttry {\n\t\t\tconst { signedTx } = await sigma.remoteSign(keyHost, authToken);\n\t\t\ttx = signedTx;\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t\tthrow new Error(`Remote signing to ${keyHost} failed`);\n\t\t}\n\t}\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};","import { type PrivateKey, Transaction, SatoshisPerKilobyte, P2PKH, type Script, type TransactionOutput } from \"@bsv/sdk\";\nimport { DEFAULT_SAT_PER_KB } from \"./constants\";\nimport OrdP2PKH from \"./ordP2pkh\";\nimport type { Utxo, Destination, MAP, Payment } from \"./types\";\nimport { fromB64Utxo } from \"./utils/utxo\";\n\nexport const sendOrdinals = async (\n\tpaymentUtxos: Utxo[],\n\tordinals: Utxo[],\n\tpaymentPk: PrivateKey,\n\tchangeAddress: string,\n\tordPk: PrivateKey,\n\tdestinations: Destination[],\n\tsatsPerKb: number = DEFAULT_SAT_PER_KB,\n\tmetaData?: MAP,\n\tadditionalPayments: Payment[] = [],\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb);\n\tconst tx = new Transaction();\n\n\t// Inputs\n\t// Add ordinal inputs\n\tfor (const ordUtxo of ordinals) {\n\t\tconst input = fromB64Utxo(ordUtxo, new OrdP2PKH().unlock(ordPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Add payment inputs\n\tfor (const paymentUtxo of paymentUtxos) {\n\t\tconst input = fromB64Utxo(paymentUtxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Outputs\n\t// check that ordinals coming in matches ordinals going out if supplied\n\tif (destinations.length !== ordinals.length) {\n\t\tthrow new Error(\n\t\t\t\"Number of destinations must match number of ordinals being sent\",\n\t\t);\n\t}\n\n\t// Add ordinal outputs\n\tfor (const destination of destinations) {\n\t\tlet s: Script;\n\t\tif (\n\t\t\tdestination.inscription?.dataB64 &&\n\t\t\tdestination.inscription?.contentType\n\t\t) {\n\t\t\ts = new OrdP2PKH().lock(\n\t\t\t\tdestination.address,\n\t\t\t\tdestination.inscription.dataB64,\n\t\t\t\tdestination.inscription.contentType,\n\t\t\t\tmetaData,\n\t\t\t);\n\t\t} else {\n\t\t\ts = new P2PKH().lock(destination.address);\n\t\t}\n\n\t\ttx.addOutput({\n\t\t\tsatoshis: 1,\n\t\t\tlockingScript: s,\n\t\t});\n\t}\n\n\t// Add additional payments if any\n\tfor (const p of additionalPayments) {\n\t\ttx.addOutput({\n\t\t\tsatoshis: p.amount,\n\t\t\tlockingScript: new P2PKH().lock(p.to),\n\t\t});\n\t}\n\n\t// Add change output\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\tconst changeOut: TransactionOutput = {\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t};\n\ttx.addOutput(changeOut);\n\n\tawait tx.fee(modelOrFee);\n\tawait tx.sign();\n\n\treturn tx;\n};\n","import { type PrivateKey, Transaction, SatoshisPerKilobyte, P2PKH, type TransactionOutput } from \"@bsv/sdk\";\nimport { DEFAULT_SAT_PER_KB } from \"./constants\";\nimport type { Utxo } from \"./types\";\nimport { fromB64Utxo } from \"./utils/utxo\";\n\n// sendUtxos sends p2pkh utxos to the given destinationAddress\nexport const sendUtxos = async (\n\tutxos: Utxo[],\n\tpaymentPk: PrivateKey,\n\tdestinationAddress: string,\n\tamount: number,\n\tsatsPerKb: number = DEFAULT_SAT_PER_KB,\n): Promise<Transaction> => {\n\tconst modelOrFee = new SatoshisPerKilobyte(satsPerKb);\n\n\tconst tx = new Transaction();\n\n\t// Inputs\n\tfor (const utxo of utxos) {\n\t\tconst input = fromB64Utxo(utxo, new P2PKH().unlock(paymentPk));\n\t\ttx.addInput(input);\n\t}\n\n\t// Outputs\n\tconst sendTxOut: TransactionOutput = {\n\t\tsatoshis: amount,\n\t\tlockingScript: new P2PKH().lock(destinationAddress),\n\t};\n\n\ttx.addOutput(sendTxOut);\n\n\t// Change\n\tconst changeAddress = paymentPk.toAddress().toString();\n\tconst changeScript = new P2PKH().lock(changeAddress);\n\n\tconst changeOut: TransactionOutput = {\n\t\tlockingScript: changeScript,\n\t\tchange: true,\n\t};\n\n\ttx.addOutput(changeOut);\n\n\t// Calculate fee\n\tawait tx.fee(modelOrFee);\n\n\t// Sign the transaction\n\tawait tx.sign();\n\n\treturn tx;\n};"],"names":["toHex","asciiStr","Buffer","from","toString","OrdP2PKH","_P2PKH","apply","this","arguments","prototype","lock","address","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fileHex","trim","Error","fileMediaType","inscriptionAsm","P2PKH","toASM","app","type","mapCmdValue","_i","_Object$entries","Object","entries","length","_Object$entries$_i","key","value","LockingScript","fromASM","fromB64Utxo","utxo","unlockScriptTemplate","input","fromUtxo","_extends","script","sourceTXID","txid","createOrdinals","utxos","destinations","paymentPk","changeAddress","satsPerKb","signer","additionalPayments","_step","_temp2","_result3","_exit","Promise","resolve","tx","fee","modelOrFee","then","sign","SatoshisPerKilobyte","Transaction","_iterator","_createForOfIteratorHelperLoose","done","unlock","addInput","console","warn","_step2","_iterator2","destination","inscription","addOutput","satoshis","lockingScript","dataB64","contentType","_step3","_iterator3","p","amount","to","change","idKey","keyHost","_temp","authToken","sigma","Sigma","remoteSign","_ref","signedTx","_catch","e","log","_sigma$sign","reject","sendOrdinals","paymentUtxos","ordinals","ordPk","_destination$inscript","_destination$inscript2","s","_iterator4","_step4","changeScript","sendUtxos","destinationAddress","sendTxOut","toAddress"],"mappings":"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"}